ItemNr,Question,Answer
1,Instanceof [4],myObject instanceof ClassNEWLINEComparing unrelated classes does not compileNEWLINECompare to null returns falseNEWLINEInstance can be compared to all interfaces as a subclass could implement
2,Equals [2 notes],Reflexive (a to a > true); Symmetric(a to b = b to a); Transitive (if a to b & b to c then a to c); Consistent (a to b = a to b) NEWLINEComparison to null >> false
3,Equals steps [4],Input Object obj; NEWLINECheck instance of; (Can also be used to compare arrays)NEWLINECast and compareNEWLINEReturn primitive boolean
4,hashCode [3 notes],Use ‘fixed’ variables. E.g. don't use weight which could changeNEWLINEWhen equals is true hashcode should be sameNEWLINEobj.hashCode();
5,Enum methods [4],s.name () // Returns valueNEWLINEs.ordinal () // Returns position as intNEWLINESeason.valueOf("Summer"); // Returns Enum constantNEWLINESeason.values() // Returns array of values
6,Enum notes [3],enum Season { WINTER SUMMER }; Upper case is conventionNEWLINESemicolon compulsory when more than values are listedNEWLINETry to keep enums simple
7,Enum usage [7],Do not extendNEWLINEDo not compare to int; NEWLINECan use in switch but use SUMMER not Season.SUMMER!NEWLINECan be privateNEWLINECan not be members but not localNEWLINECan be printed directly // Prints SUMMER not Season.SUMMERNEWLINEBoolean.False // Works is a thing..
8,Enum advanced [2],Can add state SUMMER (“warm”) also add field and private or default (!) constructor (not protected or public). Field may be public!NEWLINEOr assign method to each value and use overall abstract or default method. eg WINTER { public void doSometh() { ..} } SUM...
9,Member inner classes [6],Can be public private protected or defaultNEWLINECan be abstract or finalNEWLINECannot declare static membersNEWLINECompiling creates two .class files e.g. Outer.class & Outer$Inner.classNEWLINEHave access to all members of enclosing class using Outer.this.member or Level1.Level2.this.m or Level2.this.mNEWLINEInstantiated using new Outer.new Inner(); or outer.new Inner(); // Can't be instantiated directly from static (!) main method!
10,Local inner classes - Declared in method [5],Same as member inner except: NEWLINENo access specifier (as already local to the method). Cannot be staticNEWLINEOnly have access to local variables if effectively final (value only set once see p. 29)NEWLINECan be instantiated within method using new Inner (without object of outer class)NEWLINECan be instantiated within method object of outer class
11,Anonymous inner class [5],Does not get name just bodyNEWLINEExtends existing class or implements interface NEWLINEabstract class MyAbs{ abstract void doSometh(); } // The abstract class without method implementationNEWLINEMyAbs anno = new MyAbs() { void doSometh() { [implementation] } }; // Create anonymous class with implementationNEWLINEEnds in semicolon! Watch out for this! 
12,Static nested classes [6],Can be instantiated without objects of enclosing classNEWLINECannot access members of enclosing class without explicit objectNEWLINECan be private etcNEWLINEStatic nested classes can be imported using either import static or normal importNEWLINEimport static bird.Toucan.Beak;NEWLINECan be extended by concrete (non-static) member/inner classes.
13,Ch01 - Other [2],Abstract classes can extend concrete classesNEWLINEIf you overwrite the public String toString method that will get called when printing object
14,Functional interface - @FunctionalInterface [2 notes],Contains exactly one abstract method which it may contain through inheritanceNEWLINEMay contain other static/default methods
15,Lambda Rules [5],If more than one variable parentheses are requiredNEWLINEIf input variables are declared all must be declared and parentheses are requiredNEWLINEWhen return key word is used {} are requiredNEWLINEVariables must be initialized if used (don't get default values)NEWLINEHas access to final members and cannot reuse the same identifiers
16,Polymorphism [5],The reference determines which properties are availableNEWLINEThe object determines the behaviorNEWLINEMethods always call the instance variables available in the object // !!!NEWLINEStatic methods behave depending on referenceNEWLINEVariables behave like static methods
17,Design pattern: Singleton [5 3 important pieces],Single shareable instance; Used by multiple instances; Faster data loadingNEWLINEPrivate constructor - private SingletonName() {}NEWLINEPrivate static final member/instance - private static final SingletonName instance = new SingletonName();NEWLINEAccessed using public static method - public static SingletonName getInstance() { return instance; }NEWLINEBecause the constructor is private the singleton class becomes effectively final because a subclass constructor won't be able to call super();
18,Design pattern: Singleton with Lazy instantiation [3 points],Check is instance==null in get InstanceNEWLINEinstance is not finalNEWLINEIs not thread safe unless marked as synchronized
19,Design pattern: Creating Immutable objects [5],Use constructors to set all propertiesNEWLINENo settersNEWLINEMark instance variables private and finalNEWLINEDon't allow access to mutable objects (return copies instead or use Collections.unmodifiableList())NEWLINEPrevent overwriting of methods ((mark class OR methods final) OR mark the constructor private and use a factory pattern)
20,Design pattern: Builder pattern [3],Separate class to set and build instanceNEWLINETightly coupledNEWLINESometimes static inner class can call private constructor
21,Design pattern: Factory pattern [1],Calls relevant class based on e.g. the animal name in switch statement
22,Generic Methods [4 notes],Useful for static methods where the generic isn't determined by the classNEWLINEpublic static <T> void methodName(T t) ()NEWLINEpublic static <T> T methodName(T t) ( return t; ) // Extra T required as method returns somethingNEWLINECan be called using: ClassName.<String>methodName(s); // Complicated but valid <> not required
23,Bounds - Allows methods to accept lists of limited types [4],List<?> list = ..NEWLINEUpper bound: <? extends Number>; Number of anything that extends NumberNEWLINELower bound: <? super String>; String or super classes of // This is the only one you can add element to directly!NEWLINEUse as reference only
24,Collections [6],List: ordered collection; May contain duplicates; Access by indexNEWLINESet: No duplicate entriesNEWLINEQueue: Has order; Typically first in-first out other orderings possibleNEWLINEMap: Keys to values no duplicate keysNEWLINECan’t be null: When sorting is involved (everything that is labelled 'tree'); ArrayDeque; HashtableNEWLINECan be printed directly using System.out.println();
25,Common collection methods [6],boolean add(E element); NEWLINEboolean contains(Object object); NEWLINEboolean remove(Object object);NEWLINEint size(); NEWLINEvoid clear(); NEWLINEboolean isEmpty(); 
26,List: Adding getting setting removing [5],void add(E element); NEWLINEvoid add(int index E element); NEWLINEE get(int index); NEWLINEE set(int index E e)	// Replaces and return originalNEWLINEvoid remove(int index); // Different from common method this takes primitive!
27,List: Index [2],int indexOf(Object o); // Find first; -1 if not foundNEWLINEint lastIndex(Object o); // Find last; -1 if not found
28,Old List Looping Method [1 3],Iterator iter = list.iterator(); while(iter.hasNext()) { String string = (String) iter.next(); } // hasNext >> next
29,Set - No duplicates [2],HashSet - Uses HashCode to quickly retrieve - No sortingNEWLINETreeSet - Has order - Sorts - Needs to implement Comparable
30,TreeSet - Implement NavigableSet interface [4 methods],E lower(E e) // < e; E floor(E e) // <= e; E ceiling(E e) // >= e; E higher(E e) // > e // or returns nullNEWLINElower < floor <= e <= ceiling < higherNEWLINENEWLINEQueue [3 types 8 methods]
31,Queue [3 types 8 methods],ArrayDeque; LinkedList; Stack;NEWLINEFIFO (most common); ArrayDeque: offer > peek > pollNEWLINELIFO; Stack: push > peek > pop
32,Queue: Adding [3],boolean add(E e); // Adds element to the back returns true or throws exceptionNEWLINEboolean offer(E e); // Adds element to the back returns true/false [ArrayDeque]NEWLINEvoid push(E e); // Adds element to start makes it a double ended queue
33,Queue: Peeking [2],E peek(); Returns next element or null if empty [ArrayDeque Stack]NEWLINEE element(); // Returns next element throws exception if queue is empty
34,Queue: Removing [3],E poll(); Removes and returns next element or null if empty [ArrayDeque]NEWLINEE remove(): Remove and returns next element or throws exceptionNEWLINEE pop(); // Removes and returns next element throws exception if empty
35,Stack methods [3],void push(E e); // Adds element to the front of the queue. This makes it a double ended queue [ArrayDeque Strack]NEWLINEE pop(); // Removes and returns next element throws exception if emptyNEWLINEE peek(); Returns next element or null if empty [ArrayDeque Stack]
36,Map: Putting getting and removing [3],V put(K key V value) // Adds or replaces key/value pair. Returns previous value or null. Adding the same key overwrite does not throw an Exception!NEWLINEV get(Object key) // Returns values based on keyNEWLINEV remove(Object key) // Returns null if not found
37,Map: Common methods [3],int size(); NEWLINEboolean isEmpty(); NEWLINEvoid clear() // Removes all keys and values
38,Map: Contains [2],boolean containsKey(Object key); NEWLINEboolean containsValue(Object); // There is no .contains() method
39,Map: Keys and values [2],Set<K> keySet() // Returns keys e.g. map.keySet();NEWLINECollection<V> values() // Returns values e.g. map.values();
40,Comparable - Interface - implement compareTo method by class [5],Return: Zero when equal; <0 - current object is smaller; >0 - current object is greaterNEWLINEid – a.id sorts ascending. e.g. this - thatNEWLINELegacy code uses object as input and thus requires casting before comparisonNEWLINEStrongly recommended that compareTo() and equals() are consistentNEWLINEComparable is a functional interface but it does not make sense to implement using lamba as the purpose is the implement inside the object being compared
41,Comparator [5],Separate class<> that allows for sorting by different variables NEWLINEImplemented as inner classNEWLINEMethod: compareNEWLINEMethod can be implemented using lambaNEWLINECan be used to implement multiple fields
42,Searching and Sorting [2],Collections.sort(myElements) expects elements to implement Comparable other fails to compileNEWLINECan be sorted by also passing a Comparator to Collections.sort(ducks byWeight)
43,Collection methods/iterators? [9 6 methods],list.removeIf(s -> s.startsWith("A"));NEWLINElist.replaceAll(x -> x*2);NEWLINElist.forEach(System.out::println); // Only takes Consumer<> no variations!NEWLINEmap.merge(someKey someAltValue BiFunction); [3]NEWLINEKey already in map: Result of functionNEWLINEKey not in map: Value addedNEWLINEFunction returns null for existing value: RemoveNEWLINEmap.computeIfPresent NEWLINEmap.computeIfAbsent
44,map.merge(someKey someAltValue BiFunction); [3],Key already in map: Result of functionNEWLINEKey not in map: Value addedNEWLINEFunction returns null for existing value: Remove
45,Standard Interfaces [8],Functional InterfaceNEWLINE# ParametersNEWLINEReturn TypeNEWLINEMethodNEWLINESupplier<T>NEWLINE0NEWLINETNEWLINEget
46,Optional - Creating [3],Optional.empty();NEWLINEOptional.of(...); // Create optionals cannot use nullNEWLINEOptional.ofNullable(...); // Can handle null
47,Optional - Reading [7 8 methods],opt.get(); // Throws NoSuchElementException (logical)NEWLINEboolean opt.isPresent(); NEWLINEopt.ifPresent(Consumer c); NEWLINEopt.orElse(T other); // Returns other value if none presentNEWLINEopt.orElseGet(Supplier S); // Runs supplier and returns other value if none present e.g. opt.orElseGet(() -> Math.random()));NEWLINEopt.orElseThrow(Supplier S) // Throws specified exception if no value e.g. opt.orElseThrow(() -> new RuntimeException()));NEWLINEAlso has methods: filter(P) map(F/U)
48,Cr;eate Streams [6 ways],Stream<String> empty = Stream.empty(); NEWLINEStream.of(1 2 3); // From dataNEWLINEStream<String> fromList = list.stream();  // Don't do this on MapNEWLINElist.parallelStream(); // From list (sorting does not affect original list)NEWLINEStream<Double> randoms = Stream.generate(Math::random); // Random numbersNEWLINEStream<Integer> oddNumbers = Stream.iterate(1 n -> n + 2); // Based on previous value
49,Intermediate Operations [8],.filter(predicate)NEWLINE.distinct()  // Removes duplicates using equalsNEWLINE.limit(int) // NEWLINE.skip(int)NEWLINE.map()  // Uses Function or UnaryOperatorNEWLINE.flatMap() // Always produces a non-parallel stream requires lamba (to convert to stream)NEWLINE.sorted() // Note Comparator.reverseOrder() not Comparator::reverseOrderNEWLINE.peek() // Doesn't change stream
50,Terminal Operations [10 3-2-3-1-3-1 = 13],long count(); Optional<T> min(); Optional<T> max(); // Reductions; Returns Optionals! min max need Comparator argNEWLINEThese is no sum(); // Only exists for primitive streamsNEWLINEfindAny(); findFirst(); // Returns Optional<T> these are not reductions they don't take arguments. Returns Optionals!NEWLINEallMatch(); anyMatch(); noneMatch(); // boolean or runs foreverNEWLINEforEach();NEWLINEReduce: Stream.of("h""i").reduce("" (s c) -> s + c); // Used BinaryOperator or BiFunctionNEWLINE2 arg > Object; start value + accumulatorNEWLINE3 arg > Object; start value + accumulator + combiner > Most useful for parallel streamNEWLINE1 arg > Optional as may be empty! CollectorNEWLINECollect: Stream.of("h""i""g""h").collect(StringBuilder::new StringBuilder::append StringBuilder::append);
51,Printing a stream [3],s.limit(5).forEach(System.out::println); // Print using forEachNEWLINEs.peek(System.out::println).count(); // Print using peek remember to add a terminal operationNEWLINESystem.out.println(s.collect(Collectors.toList())); // Convert to list and print
52,Primitive Streams [3 types 4 methods],IntStream; LongStream; DoubleStream; // Watch spellingNEWLINEIntStream.range(16); IntStream.rangeClosed(15);NEWLINEDoubleStream.generate(Math::random); DoubleStream.iterate(0.5 d -> d / 2);
53,Functions to convert different stream type [3],To same always map i.e. can't call others on self!NEWLINESteam = mapToObj; DoubleStream = mapToDouble; IntStream = mapToInt; LongStream = mapToLongNEWLINEWatch out for mapToBool nonsense!
54,Interface to use as parameter in those map... functions [2],StartToEnd e.g. IntToLongFunction ToLongFunctionNEWLINESelfUnaryOperator e.g. DoubleUnaryOperator (stream to stream is just Function)
55,Functional interfaces for double int long [5 3x6],Double/Int/Long  Supplier/Consumer/Predicate/Function<R>/UnaryOperator/BinaryOperator NEWLINEReturn generic is specified for Function and only for Function!NEWLINEmethods often renamed to reflect type (not for Consumer Predicate Function)NEWLINEThere's no BiConsumer BiPredicate BiFunction (only BinaryOperator)NEWLINEBooleanSupplier also exists
56,Conversion Interfaces To and Between Primitive Streams [3x23;3x33;4x1],ToDouble/ToInt/ToLong Function<T>/BiFunction<TU> // applyAs Double/IntLongNEWLINEDouble/Int/Long To Double/Int/Long Function // applyAs Double/IntLongNEWLINEObj Double/Int/LongConsumer<T> // Accept note generic parameter // Takes Object and primitive
57, Optional methods [2 4],Getting as primitive: getAsDouble(); getAsInt(); getAsLong();NEWLINE.orElseGet(Double/Int/LongSupplier);
58,Stats [3],.max(); returns OptionalDouble/Int/Long;NEWLINE.sum(); returns double/int/long;NEWLINE.average(); // Always return OptionalDouble not written in full >> Actually it is written in full! (Double check in book)
59,Summary Statistics [5],IntSummaryStatistics stats = ints.summaryStatistics(); // Written in full!NEWLINEstats.getMax(); NEWLINEstats.getMin();NEWLINEstats.getAverage(): // Apparently returns Double and not Optional<Double> (different from above)NEWLINEIntSummaryStatistics incomeStats = Employee.persons() .stream()
60,Classes [4 types],LocalDate NEWLINELocalTime NEWLINELocalDateTimeNEWLINEZonedDateTime 
61,Create [6],LocalTime.now() method creates instanceNEWLINELocalDate.of(2015 Month.JANUARY 31)NEWLINEZondedDateTime.of(201512061530200zone);NEWLINEZondedDateTime.of(localDate localTime zone); // BetterNEWLINEZoneId zone = ZoneId.of(“US/Eastern”);NEWLINEZoneId.systemDefault();
62,To Epoch [2],long LocalDate.toEpochDay()NEWLINElong Local/ZonedDateTime.toEpochSecond()
63,Instants [2 methods],Specific moment in time based on GMTNEWLINEInstant.now()
64,Manipulating Dates and Times [2x8+2 2 notes],.plus/minusYears Months Weeks Days Hours Minutes Seconds NanosNEWLINE.plus/minus(period); 
65,Periods (Not for time) [5 2 notes],Period.ofYears(); .ofMonths(); ofWeeks(); ofDays(); of(year month day);NEWLINEDon't string together only last one will applyNEWLINEP1Y2M3D or P21D // when printingNEWLINENEWLINEDuration (for time (and days)) [4 7 methods 4 notes]
66,Duration (for time (and days)) [4 7 methods 4 notes],Duration.ofDays(); .ofHours(); .ofMinutes(); .ofSeconds(); .ofMillis(); .ofNanos(); NEWLINEDuration.of(1 ChonosUnit.Days); ChonosUnit.HOURS; .MINUTES; .SECONDS; .MILLIS; .NANOS;NEWLINEOnly one unit at a time don't string together only last one will applyNEWLINEPT1H PT10S // Example of when printing
67,Comparing [3],book .isBefore(other)/isAfter(other); // e.g. a.isBefore(b); // Date and timeNEWLINEpublic long until(Temporal endExclusive  TemporalUnit unit) //  e.g. date1.until(date2 ChronoUnit.DAYS)); // Days between 1 & 2NEWLINEChronosUnit.MINUTES.between(timeOne timetwo); // Minutes between...
68,Get date elements [4],.getDayOfWeek(); MONDAY // Returns EnumNEWLINE.getMonth(); JANUARY // Returns EnumNEWLINE.getYear(); 2020  NEWLINE.getDayOfYear(); 20
69,DateTimeFormatter [2],import java.time.format.*;NEWLINEOnly  call on appropriate data types
70,Format directly [3],date.format(DateTimeFormattter.ISO_LOCAL_DATE); 2020-01-20NEWLINEtime.format(DateTimeFormattter.ISO_LOCAL_TIME); 11:12:34NEWLINEdateTime.format(DateTimeFormattter.ISO_LOCAL_DATE_TIME); 2020-01-20T11:12:34
71,Create formatter [2],DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT); // Only DateNEWLINEDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT); // Only prints time
72,DateTime can be either object of parameter [2],shortDateTime.format(dateTime); // 1/20/20 (Date piece only)NEWLINEdateTime.format(shortDateTime); // Equivalent!
73,Format styles [3],FormatStyle.ISO_LOCAL_DATE/_TIME_DATE_TIME // 2020-01-20T11:12:34NEWLINEFormatStyle.SHORT // 1/20/20 11:12 AMNEWLINEFormatStyle.MEDIUM // Jan 20 2020 11:12:34 AM
74,Pattern [8],FormatStyle.ofPattern(“MMMM dd yyy hh:mm”); // Can throw runtime exception with non usable patternNEWLINEyyyy - year: yy = 16 yyyy = 2016NEWLINEMMMM - Month: M = 1 MM = 01 MMM = Jan MMMM = January // Month is the only one using capitalsNEWLINEdd - date: d = 1 dd = 01NEWLINEhh - hour: h = 1 hh = 01NEWLINEmm - minuteNEWLINE =    : = :NEWLINE.parse(“01 02 2015” f);
75,Formatting Numbers [7 5 methods 2 notes],en = NumberFormat.getInstance(Locale.US); // Or no argumentNEWLINEen = NumberFormat.getNumberInstance(...);NEWLINEen = NumberFormat.getCurrencyInstance(...);NEWLINEen = NumberFormat.getPercentInstance(...);NEWLINEen = NumberFormat.getIntegerInstance(...);NEWLINENumberFormat is created using a FactoryNEWLINEen.parse(someString); Converts string to number using NumberFormat. Gives error when string does not start with number
76,Notes [2],If catch and finally both throw an exception the one from the finally get throughNEWLINERethrowing Exception: When you write Exception e in the catch statement java assumes catch the exception that the method throws
77,Create exceptions [2],Extend Exception or RuntimeExceptionNEWLINEConstructors (No argument Exception e String message)
78,Multi catch [3],Use | but only one eNEWLINEMeant to catch unrelated exceptions NEWLINEDo not reassign a new exception to e // As compiler doesn't know which one it's going to be
79,Try with resources [7],try (MyClass c = new MyClass()) { c.doSometh(); } NEWLINEResources are closest in reverse order after the try statements ends after which catch and finally are run!NEWLINEImplements AutoCloseable (there's also a thing called Closeable which also works)NEWLINEImplement close() methodNEWLINERecommended that close throws specific or no exceptionsNEWLINEIf close is able to throw an exception a catch statement is required NEWLINEClosable only allow to throw IOException
80,Suppressed Exception [2],Multiple exceptions only the first is 'active' the rest are suppressedNEWLINEfor (Throwable t : e.getSuppressed()) { t.getMessage(); }
81,Assertion - When you expect a boolean expression to be true [3 forms],assert i > 0; NEWLINEassert(I>0); NEWLINEassert i > 0: "OhNo!" // Look for colon! Any value or Supplier
82,Concurrent Interfaces [2],Runnable - void run(); // For actionNEWLINECallable<T> T run(); // Returns generic and throw Exceptions! For tasks!
83,Create thread [10],Beware of cases where run is called instead of start as those run on the same threadNEWLINEimplements Runnable (preferred)NEWLINEOverwrite void run()NEWLINEIn main  (new Thread(new MyClass))).start();NEWLINEAllow you to extend other classesNEWLINEBetter OO designNEWLINEextends ThreadNEWLINEOverwrite void run()NEWLINEIn main (new MyClass()).start();NEWLINEPro potential to set priority
84,Polling with Sleep [2],Check whether thread has finished include Thread.sleep(...); To prevent constant checking.NEWLINEAdd to main: throws InterruptedException or try/catch block
85,ExecutorService [7 5],Import .java.util.concurrent.*;NEWLINEObtain through Executors Factory classNEWLINE                 ExecutorService service = Executors.newSingleThreadExecutor();NEWLINEScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();NEWLINE                 ExecutorService service = Executors.newCachedThreadPool();NEWLINE                 ExecutorService service =  Executors.newFixedThreadPool(int nThreads);NEWLINEScheduledExecutorService service = Executors.newScheduledTheadPool(int nThreads);
86,Executor service method [6],service.execute(Lamba Expression);NEWLINEAdd try/finally { if(service!=null) service.shutdown();NEWLINEisShutdown() // true after .shutdown() calledNEWLINEservice.awaitTermination(long timeout TimeUnit unit); >> Important to wait even if all else is implemented correctly!NEWLINEisTerminated() // true after remaining threads have finished runningNEWLINEshutdownNow() // Attempt to stop all running tasks. Returns List<Runnable> with non-finished tasks
87,Future methods [5],boolean isDone(); // Is the task completeNEWLINEboolean isCancelled()NEWLINEboolean cancel()NEWLINEV get(); // Return null for Runnable // has Exceptions that need to be caught!NEWLINEV get(long timeout TimUnit unit) // In addition has timeoutException
88,Scheduling Tasks [4],schedule(Callable<V> callable long delay TimeUnit unit);NEWLINEschedule(Runnable command long delay TimeUnit unit);NEWLINEscheduleAtFixedRate() // Runnable 4 agrsNEWLINEscheduleAtFixedDelay // Runnable 4 agrs
89,Atomic Classes [4. 7],AtomicBooleanNEWLINEAtomicInteger; AtomicIntegerArrayNEWLINEAtomicLong; AtomicLongArrayNEWLINEAtomicReference; AtomicReferenceArray
90,Atomic Methods [2 7],get(); set(); getAndSet()NEWLINEincrementAndGet(); getAndIncrement(); decrementAndGet(); getAndDecrement();
91,parallel reduce() requirements [3 args],Identity: must be defined such that .apply(indentify u) is equal to uNEWLINEAccumulator must be associative and stateless such that (a op b) op c == a op (b op c)NEWLINECombiner: must be associative and stateless it aligns with the accumulator
92,parallel collect() requirements [3],the stream is parallelNEWLINECollector.Characteristics.CONCURRENTNEWLINECollector.Characteristics.UNORDERED
93,CyclicBarrier [4 points],CyclicBarrier c = new CyclicBarrier(4); // number is threatcount to be reached otherwise hangsNEWLINETakes second argument (lambda) to print somethingNEWLINEc.await(); // Waits for all tasks to finishNEWLINENeeds catch (InterruptedException | BrokenBarrierException e) {}
94,Identifying Threading Problems [4],Liveness: The ability of an application to execute in a timely mannerNEWLINEDeadlock: Two threads are waiting for each other; Can't happen with SingleThreadExe...NEWLINEStarvation: A threat is unable to get access to the resource it needsNEWLINELivelock: Occurs when threats are trying to resolve or avoid a deadlock
95,Managing race conditions [2],Two requests are being submitted at the same timeNEWLINEIdeally: access one and deny the other (rather than denying both)
96,InputStream - OutputStream > Abstract!! Do not instantiate! [3],FileInputStream - FileOutputStream > BytesNEWLINEBufferedInputStream - BufferedOutputStreamNEWLINEObjectInputStream - ObjectOutputStream > Higher level!
97,Reader - Writer > Also abstract! Do not instantiate! [3],FileReader - FileWriter > CharactersNEWLINEBufferedReader - BufferedWriterNEWLINEInputStreamReader - OutputStreamWriter > Character data from stream
98,Printers [2],PrintStream > Writes formatted java objects to binary streamNEWLINEPrintWriter > Writes java objects to text based output
99,Marking and reset and Skipping [4],.markSupported(); // Check support for marking; Watch for question on this will throw exception!NEWLINE.mark(int n); // Mark a location for the next n bytes; if not supported throws runtime exceptionNEWLINE.skip(numberOfBytesToSkip)NEWLINE.reset() // Go back to marked location Passing mark read limit may lead to exception when calling .reset()
100,Serializable [7],Tagging or marker interface (has no methods)NEWLINEClass and object within must be marked Serializable or transient (indicating it does not need to be saved)NEWLINEThrows NotSerializableExceptionNEWLINEStatic variables are ignored (however values may have been retained if objects are serialized and immediately deserialized!)NEWLINEprivate static final long serialVersionUID = 1L; // Is stored; Watch for spelling; Recommended not requiredNEWLINEDeserialization may throw ClassNotFoundExceptionNEWLINENo class constructor or default initializations are used in the deserialization process
101,PrintStream - PrintWriter - Do not throw exceptions ? [5],Can open and write to files directly NEWLINEPrintWriter can work with OutputStream and format tooNEWLINESystem.out and System.err are actually PrintStream objectsNEWLINE.print(); println();NEWLINE.format(); = .printf();
102,Console write methods memorize these! [6],console.printf();  // Does not need the writer partNEWLINEconsole.format(); // Does not need the writer partNEWLINEconsole.writer().println; // Needs the writer partNEWLINEconsole.writer().print // Needs the writer partNEWLINEconsole.writer().write() // Needs the writer partNEWLINEconsole.flush(); // Write remaining output immediately; Recommended to call before read commands...
103,Console read methods [3],console.reader().read();NEWLINEconsole.readLine(); // Without reader()NEWLINEconsole.readPassword(); // Remember returns char[]; More secure avoids use of StringPool memory can be erased
104,File elements [4 3],file.getName(); // Return last elementNEWLINEfile.getAbsolutePath(); // Adds rootNEWLINEfile.getParent() // Returns abstract pathname or null if parent directory is not namedNEWLINEThere is no .getRoo()t method
105,File characteristics [5],file.exists(); // Non existing >> falseNEWLINEfile.isDirectory(); // Non-existing >> falseNEWLINEfile.isFile(); // Non-existing >> falseNEWLINEfile.length(); // Non-existing >> 0NEWLINEfile.lastModified // Returns number of milliseconds since the epoch non-existing >> 0
106,File alterations [4],file.renameTo(File); // There is no .copy() method NEWLINEfile.delete(); // returns boolean NEWLINEfile.mkdir(); NEWLINEfile.mkdirs()  // Makes directory; mkdirs - including missing parent directories
107,File listing [2],.listFiles()	// Returns File[] arrayNEWLINE.list(); // Returns String[] array >> Note that this is different from Files.list()!
108,Create Path [5],Paths.get(String); NEWLINEPaths.get(varag String[]); // Overloaded with varargNEWLINEPaths.get(URI); // URI (Uniform Resource Identifier) must reference absolute pathNEWLINEfile.toPath(); NEWLINEFileSystems.getDefault().getPath(...); // FileSystems factory class to create instances
109,Path to methods [3],path.toFile(); NEWLINEpath.toURI(); NEWLINEpath.toString();
110,Path elements [7],path.getNameCount(); // Returns the number of elements in the PathNEWLINEpath.getName(int index); // Returns a specific element of the Path as a new Path objectNEWLINEpath.subpath(0.3); // Excludes last nr obviouslyNEWLINEpath.getFileName(); // Returns PathNEWLINEpath.getRoot(); // Returns PathNEWLINEpath.getParent(); // Returns PathNEWLINEpath.toAbsolutePath(); // Create path starting from root
111,Path characteristics [1],path.isAbsolute(); // Does path start from root?
112,Path manipulate [4],path1.relativize(path2); // Show how to get to other file. Requires both to be either relative or abstract otherwise throws error!NEWLINEpath1.resolve(path2); // For joining paths; Running this with an absolute path as argument will return just the absolute path!NEWLINEpath.normalize(); // For cleaning up path symbols; Relative paths do not become absoluteNEWLINEpath.toRealPath(); // Checks that file exists after normalizing. Be sure to handle possible IOException e
113,Optional Arguments [5],NOFOLLOW_LINKS: // Don't traverse symbolic linksNEWLINEFOLLOW_LINKS  // Not the default!NEWLINECOPY_ATTRIBUTES // Also copy metadata. Default!NEWLINEREPLACE_EXISTING: Overwrite otherwise exception will be throw is file exists (not the default)NEWLINEATOMIC_MOVE: Perform the move in an atomic manner. If not supported a AtomicMoveNotSupportedException could be thrown.
114,Files check methods [2],Files.exists(path); // Does not throw an exceptionNEWLINEFiles.isSameFile(pp); // Throws IOException if either file does not exist or NoSuchFileException
115,Files alteration [6],Files.createDirectory(p); NEWLINEFiles.createDirectories(p);NEWLINEFiles.copy(pp); // Could take InputStream path options..) Can copy to outputstream which has to go second!NEWLINEFiles.move(pp);NEWLINEFiles.delete(p); // Throws IOException or RunTime DirectoryNotEmptyExceptionNEWLINEFiles.deleteIfExists(p);  
116,Files reading writing [4],Files.newBufferedReader(p); NEWLINEFiles.newBufferedWriter(p); // Use try with resources catch IOExp for reader/writer methodsNEWLINEFiles.readAllLines(p); // IOExcept list<String>  // Not a stream memory intensive // IOExceptNEWLINEFiles.lines(p); // IOExcept Stream<String> // Better than readAllLines(); Creates Stream<String> loads one bit at a time // IOExcept
117,File Attributes (specific to NIO.2) [9 methods],Files.isDirectory(); // Has to exist can refer to symbolic linkNEWLINEFiles.isRegularFile(); NEWLINEFiles.isSymbolicLink();NEWLINEFiles.isHidden(); // Catch IOException eNEWLINEFiles.size(); // Instead of .length(); !!NEWLINEFiles.getLastModifiedTime(); NEWLINEFiles.setLastModifiedTime();NEWLINEFiles.getOwner(); NEWLINEFiles.setOwner();
118,Walking and Searching using Files [6 3 methods],Java lazy depth first. Avoid circular paths throws FileSystemLoopExceptionNEWLINEStream<Path> Files.walk(path). May throw error when missing access permission. NOFOLLOW_LINKS is defaultNEWLINEAlso goes through subdirectoriesNEWLINEMay encounter files it does not have permission to readNEWLINEStream<Path> Files.find(path depth BiPredicate). ...; // Catch Exception e; BiPredicate using Path BasicFileAttributesNEWLINEStream<Path> Files.list(path) throws IOException // Note difference with File.list() // Only lists files in current directory
119,View creation [4],BasicFileAttributes data = Files.readAttributes(path BasicFileAttributes.class); // Cannot modify watch for questions!NEWLINEBasicFileAttributeView.class // Can also alterNEWLINEDosFileAttributes; NEWLINEPosixFileAttributes
120,View access [4],data.isOther(); NEWLINEdata.lastAccessTime(); NEWLINEdata.creationTime(); NEWLINEdata.fileKey();
121,View modifying [4],Make sure the 'view' versions are used consistentlyNEWLINEBasicFileAttributeView view = Files.getFileAttributeView(pathBasicFileAttributeView.class);NEWLINEBasicFileAttributes data = view.readAttributes();NEWLINEview.setTime(lastModifiedTimenull null);
122,Connection [3],conn.setAutoCommit(boolean)NEWLINEconn.commit(); // Commits all previous NEWLINEconn.rollback(); // Cancels all(!)previous statements
123,ResultSet Type [3],ResultSet.TYPE_FORWARD_ONLY	// Can’t go backward watch for question that scroll with this of default!!!NEWLINEResultSet.TYPE_SCROLL_INSENSITIVE // Can go backward. Don't get distracted by INSENSITIVE it's often the SCROLL that mattersNEWLINEResultSet.TYPE_SCROLL_SENSITIVE // Also sees latest (updated) data not well supported
124,ResultSet Concurrency Mode (second argument only but does compile but means something else) [2],ResultSet.CONCUR_READ_ONLYNEWLINEResultSet.CONCUR_UPDATABLE // Less used - Least used
125,Statement [4 methods],e.g. Statement stmt = conn.createStatement(ResultSet.YPE_SCROLL_INSENSITIVE ResultSet.CONCU_READ_ONLY);NEWLINEbool b = stmt.execute() // Can alter; Cannot return data; Boolean; true for select; false for alterationNEWLINEResultSet rs = stmt.executeQuery() // Cannot alter: Can return ResultSet (Running another query closes first rs!)NEWLINEstmt.executeUpdate() // Can alter; Return nr (int) rows changed
126,Reading ResultSet [5 9 methods],while(rs.next()) { int id = rs.getInt(“id”); }NEWLINE.getBoolean(); .getInt(...); .getDouble(); .getLong(); // Int not spelled in fullNEWLINE.getString(...); .getObject();NEWLINE.getData(); .getTime(); .getTimeStamp(); // java.sql.Date/Time/TimeStampNEWLINEArgument is column label or number; Numbers start at 1 not 0;
127,SQL Date Conversion [2],java.sql.Date sqlDate = rs.getDate(1);NEWLINELocalDate localDate = sqlDate.toLocalDate(); // This is a method not a factory
128,JDBC Date and Time [3],java.sql.Date - java.time.LocalDate - Date onlyNEWLINEjava.sql.Time - java.time.LocalTime - Time onlyNEWLINEjava.sql.TimeStamp - java.time.LocalDateTime - Date and Time
129,Scrolling ResultSet [8 methods],void afterLast(); void beforeFirst(); // Surprisingly these return void. Watch for questions on this!NEWLINEboolean first(); boolean last(); boolean next(); boolean previous() // Spelling in full!NEWLINEboolean absolute(int rowNum); boolean relative(int rowNum); // Negative numbers start from end. absolute(0) = false;NEWLINEClosing Database ResourcesNEWLINETry (Connection conn = DriverManager.getConnection(url);	….);NEWLINEThe ‘old’ way uses a finally block and lots of checks to see what still is open. NEWLINEExceptionsNEWLINEcatch(SQLException e) { e.getMessage(); e.getSQLState(); e.getErrorCode(); }
