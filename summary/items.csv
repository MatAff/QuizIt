ItemNr,Question,Answer
1,Instanceof [4],myObject instanceof ClassNEWLINEComparing unrelated classes does not compileNEWLINECompare to null returns falseNEWLINEInstance can be compared to all interfaces as a subclass could implement
2,Equals [2 notes],Reflexive (a to a > true); Symmetric(a to b = b to a); Transitive (if a to b & b to c then a to c); Consistent (a to b = a to b) NEWLINEComparison to null >> false
3,Equals steps [4],Input Object obj; NEWLINECheck instance of; (Can also be used to compare arrays)NEWLINECast and compareNEWLINEReturn primitive boolean
4,hashCode [3 notes],Use ‘fixed’ variables. E.g. don't use weight which could changeNEWLINEWhen equals is true, hashcode should be sameNEWLINEobj.hashCode();
5,Other [2 notes],Virtual method invocation - Implementation depends on classNEWLINEAnnotation - @Override - indicates a method is being overwritten 
6,Enum methods [4],s.name () // Returns valueNEWLINEs.ordinal () // Returns position as intNEWLINESeason.valueOf("Summer"); // Returns Enum constantNEWLINESeason.values() // Returns array of values
7,Enum notes [3],enum Season { WINTER, SUMMER }; Upper case is conventionNEWLINESemicolon compulsory when more than values are listedNEWLINETry to keep enums simple
8,Enum usage [7],Do not extendNEWLINEDo not compare to int; NEWLINECan use in switch, but use SUMMER, not Season.SUMMER!NEWLINECan be privateNEWLINECan not be members, but not localNEWLINECan be printed directly // Prints SUMMER, not Season.SUMMERNEWLINEBoolean.False // Works, is a thing..
9,Enum advanced [2],Can add state SUMMER (“warm”) also add field and private or default (!) constructor (not protected or public). Field may be public!NEWLINEOr assign method to each value and use overall abstract or default method. e,g WINTER { public void doSometh() { ..} }, SUM...
10,Member inner classes [6],Can be public, private, protected or defaultNEWLINECan be abstract or finalNEWLINECannot declare static membersNEWLINECompiling creates two .class files e.g. Outer.class & Outer$Inner.classNEWLINEHave access to all members of enclosing class using Outer.this.member, or Level1.Level2.this.m or Level2.this.mNEWLINEInstantiated using new Outer.new Inner(); or outer.new Inner(); // Can't be instantiated directly from static (!) main method!
11,Local inner classes - Declared in method [5],Same as member inner except: NEWLINENo access specifier (as already local to the method). Cannot be staticNEWLINEOnly have access to local variables if effectively final (value only set once, see p. 29)NEWLINECan be instantiated within method using new Inner (without object of outer class)NEWLINECan be instantiated within method object of outer class
12,Anonymous inner class [5],Does not get name, just bodyNEWLINEExtends existing class or implements interface NEWLINEabstract class MyAbs{ abstract void doSometh(); } // The abstract class without method implementationNEWLINEMyAbs anno = new MyAbs() { void doSometh() { [implementation] } }; // Create anonymous class with implementationNEWLINEEnds in semicolon! Watch out for this! 
13,Static nested classes [6],Can be instantiated without objects of enclosing classNEWLINECannot access members of enclosing class without explicit objectNEWLINECan be private, etcNEWLINEStatic nested classes can be imported using either import static or normal importNEWLINEimport static bird.Toucan.Beak;NEWLINECan be extended by concrete (non-static) member/inner classes.
14,Functional interface - @FunctionalInterface [2],Contains exactly one abstract method, which it may contain through inheritanceNEWLINEMay contain other static/default methods
15,Lambda Rules [4],If more than one variable parentheses are requiredNEWLINEIf input variables are declared all must be declared and parentheses are requiredNEWLINEWhen return key word is used {} are requiredNEWLINEVariables must be initialized if used (don't get default values)
16,Polymorphism [5],The reference determines which properties are availableNEWLINEThe object determines the behaviorNEWLINEMethods always call the instance variables available in the object // !!!NEWLINEStatic methods behave depending on referenceNEWLINEVariables behave like static methods
17,Design pattern: Singleton [3 important pieces],Single shareable instance; Used by multiple instances; Faster data loadingNEWLINEPrivate constructor - private SingletonName() {}NEWLINEPrivate static final member/instance - private static final SingletonName instance = new SingletonName();
18,Design pattern: Singleton with Lazy instantiation [3 points],Check is instance==null in get InstanceNEWLINEinstance is not finalNEWLINEIs not thread safe unless marked as synchronized
19,Design pattern: Creating Immutable objects [5],Use constructors to set all propertiesNEWLINENo settersNEWLINEMark instance variables private and finalNEWLINEDon't allow access to mutable objects (return copies instead, or use Collections.unmodifiableList())NEWLINEPrevent overwriting of methods ((mark class OR methods final) OR mark the constructor private and use a factory pattern)
20,Generic Methods [4],Useful for static methods, where the generic isn't determined by the classNEWLINEpublic static <T> void methodName(T t) ()NEWLINEpublic static <T> T methodName(T t) ( return t; ) // Extra T required as method returns somethingNEWLINECan be called using: ClassName.<String>methodName(s); // Complicated but valid, <> not required
21,Bounds - Allows methods to accept lists of limited types [3 types, 1 note],List<?> list = ..NEWLINEUpper bound: <? extends Number>; Number of anything that extends NumberNEWLINELower bound: <? super String>; String or super classes of // This is the only one you can add element to directly!
22,Collections [4, 2 notes],List: ordered collection; May contain duplicates; Access by indexNEWLINESet: No duplicate entriesNEWLINEQueue: Has order; Typically first in-first out, other orderings possibleNEWLINEMap: Keys to values, no duplicate keys
23,Common methods [6],boolean add(E element); NEWLINEboolean contains(Object object); NEWLINEboolean remove(Object object);NEWLINEint size(); NEWLINEvoid clear(); NEWLINEboolean isEmpty(); 
24,List [3 types, 7 methods],ArrayList; LinkedList; VectorNEWLINEAdding, getting, setting, removing [5]NEWLINEvoid add(E element); 
25,Adding, getting, setting, removing [5],void add(E element); NEWLINEvoid add(int index, E element); NEWLINEE get(int index); NEWLINEE set(int index, E e)	// Replaces and return originalNEWLINEvoid remove(int index); // Different from common method, this takes primitive!
26,Index [2],int indexOf(Object o); // Find first; -1 if not foundNEWLINEint lastIndex(Object o); // Find last; -1 if not found
27,Old List Looping Method [3],Iterator iter = list.iterator(); while(iter.hasNext()) { String string = (String) iter.next(); } // hasNext >> nextNEWLINENEWLINE
28,Set - No duplicates [2],HashSet - Uses HashCode to quickly retrieve - No sortingNEWLINETreeSet - Has order - Sorts - Needs to implement Comparable
29,Queue [3 types, 8 methods],ArrayDeque; LinkedList; Stack;NEWLINEFIFO (most common); ArrayDeque: offer > peek > pollNEWLINELIFO; Stack: push > peek > pop
30,Adding [3],boolean add(E e); // Adds element to the back, returns true or throws exceptionNEWLINEboolean offer(E e); // Adds element to the back, returns true/false [ArrayDeque]NEWLINEvoid push(E e); // Adds element to start, makes it a double ended queue
31,Peeking [2],E peek(); Returns next element or null if empty [ArrayDeque, Stack]NEWLINEE element(); // Returns next element, throws exception if queue is empty
32,Removing [3],E poll(); Removes and returns next element or null if empty [ArrayDeque]NEWLINEE remove(): Remove and returns next element or throws exceptionNEWLINEE pop(); // Removes and returns next element, throws exception if empty
33,Stack [3],void push(E e); // Adds element to the front of the queue. This makes it a double ended queue [ArrayDeque, Strack]NEWLINEE pop(); // Removes and returns next element, throws exception if emptyNEWLINEE peek(); Returns next element or null if empty [ArrayDeque, Stack]
34,Putting, getting and removing [3],V put(K key, V value) // Adds or replaces key/value pair. Returns previous value or null. Adding the same key overwrite, does not throw an Exception!NEWLINEV get(Object key) // Returns values based on keyNEWLINEV remove(Object key) // Returns null if not found
35,Common methods [3],int size(); boolean isEmpty(); void clear() // Removes all keys and valuesNEWLINEContains [2]NEWLINEboolean containsKey(Object key); boolean containsValue(Object); // There is no .contains() method
36,Contains [2],boolean containsKey(Object key); boolean containsValue(Object); // There is no .contains() methodNEWLINEKeys and values [2]
37,Keys and values [2],Set<K> keySet() // Returns keys e.g. map.keySet();NEWLINECollection<V> values() // Returns values e.g. map.values();
38,Searching and Sorting [2],Collections.sort(myElements) expects elements to implement Comparable other fails to compileNEWLINECan be sorted by also passing a Comparator to Collections.sort(ducks, byWeight)
39,Collection methods/iterators? [6],list.removeIf(s -> s.startsWith("A"));NEWLINElist.replaceAll(x -> x*2);NEWLINElist.forEach(System.out::println); // Only takes Consumer<>, no variations!NEWLINEmap.merge(someKey, someAltValue, BiFunction); [3]NEWLINEKey already in map: Result of functionNEWLINEKey not in map: Value added
40,map.merge(someKey, someAltValue, BiFunction); [3],Key already in map: Result of functionNEWLINEKey not in map: Value addedNEWLINEFunction returns null for existing value: Remove
41,Optional - Creating [3],Optional.empty();NEWLINEOptional.of(...); // Create optionals, cannot use nullNEWLINEOptional.ofNullable(...); // Can handle null
42,Optional - Reading [6],opt.get(); // Throws NoSuchElementException (logical)NEWLINEboolean opt.isPresent(); NEWLINEopt.ifPresent(Consumer c); NEWLINEopt.orElse(T other); // Returns other value if none presentNEWLINEopt.orElseGet(Supplier S); // Runs supplier and returns other value if none present e.g. opt.orElseGet(() -> Math.random()));NEWLINEopt.orElseThrow(Supplier S) // Throws specified exception if no value e.g. opt.orElseThrow(() -> new RuntimeException()));
43,Cr;eate Streams [6 ways],Stream<String> empty = Stream.empty(); Stream.of(1, 2, 3); // From dataNEWLINEStream<String> fromList = list.stream(); list.parallelStream(); // From list (sorting does not affect original list)NEWLINEDon't do this on a MapNEWLINEStream<Double> randoms = Stream.generate(Math::random); // Random numbersNEWLINEStream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Based on previous valueNEWLINEIntermediate Operations [8]
44,Intermediate Operations [8],.filter(predicate)NEWLINE.distinct()  // Removes duplicates, using equalsNEWLINE.limit(int) // .skip(int)NEWLINE.map()  // Uses Function, or UnaryOperatorNEWLINE.flatMap() // Always produces a non-parallel stream, requires lamba, (to convert to stream)NEWLINE.sorted() // Note Comparator.reverseOrder(), not Comparator::reverseOrderNEWLINE.peek() // Doesn't change streamNEWLINETerminal Operations [3-2-3-1-3-1 = 13]
45,Terminal Operations [3-2-3-1-3-1 = 13],long count(); Optional<T> min(); Optional<T> max(); // Reductions; Returns Optionals! min, max need Comparator argNEWLINEThese is no sum(); // Only exists for primitive streamsNEWLINEfindAny(); findFirst(); // Returns Optional<T>, these are not reductions, they don't take arguments. Returns Optionals!
46,Printing a stream [3],s.limit(5).forEach(System.out::println); // Print using forEachNEWLINEs.peek(System.out::println).count(); // Print using peek, remember to add a terminal operationNEWLINESystem.out.println(s.collect(Collectors.toList())); // Convert to list and print
47,Primitive Streams [3 types, 4 methods],IntStream; LongStream; DoubleStream; // Watch spellingNEWLINEIntStream.range(1,6); IntStream.rangeClosed(1,5);NEWLINEDoubleStream.generate(Math::random); DoubleStream.iterate(0.5, d -> d / 2);
48,Functional interfaces for double, int, long [3x6],Double/Int/Long  Supplier/Consumer/Predicate/Function<R>/UnaryOperator/BinaryOperator NEWLINEReturn generic is specified for Function, and only for Function!NEWLINEmethods often renamed to reflect type (not for Consumer, Predicate, Function)
49,Conversion Interfaces To and Between Primitive Streams [3x2,3;3x3,3;4x1],ToDouble/ToInt/ToLong Function<T>/BiFunction<T,U> // applyAs Double/IntLongNEWLINEDouble/Int/Long To Double/Int/Long Function // applyAs Double/IntLongNEWLINEObj Double/Int/LongConsumer<T> // Accept, note generic parameter // Takes Object and primitive
50,Classes [4 types],LocalDate NEWLINELocalTime NEWLINELocalDateTimeNEWLINEZonedDateTime 
51,Create [6],LocalTime.now() method creates instanceNEWLINELocalDate.of(2015, Month.JANUARY, 31)NEWLINEZondedDateTime.of(2015,1,20,6,15,30,200,zone);NEWLINEZondedDateTime.of(localDate, localTime, zone); // BetterNEWLINEZoneId zone = ZoneId.of(“US/Eastern”);NEWLINEZoneId.systemDefault();
52,To Epoch [2],long LocalDate.toEpochDay()NEWLINElong Local/ZonedDateTime.toEpochSecond()
53,Instants [2 methods],Specific moment in time based on GMTNEWLINEInstant.now()
54,Manipulating Dates and Times [2x8+2, 2 notes],.plus/minusYears, Months, Weeks, Days, Hours, Minutes, Seconds, NanosNEWLINE.plus/minus(period); 
55,Periods (Not for time) [5, 2 notes],Period.ofYears(); .ofMonths(); ofWeeks(); ofDays(); of(year, month, day);NEWLINEDon't string together, only last one will applyNEWLINEP1Y2M3D or P21D // when printingNEWLINENEWLINEDuration (for time (and days)) [7 methods, 4 notes]
56,Duration (for time (and days)) [7 methods, 4 notes],Duration.ofDays(); .ofHours(); .ofMinutes(); .ofSeconds(); .ofMillis(); .ofNanos(); NEWLINEDuration.of(1, ChonosUnit.Days); ChonosUnit.HOURS; .MINUTES; .SECONDS; .MILLIS; .NANOS;NEWLINEOnly one unit at a time, don't string together, only last one will applyNEWLINEPT1H, PT10S // Example of when printingNEWLINENEWLINEComparing [3]NEWLINEbook .isBefore(other)/isAfter(other); // e.g. a.isBefore(b); // Date and time
57,Comparing [3],book .isBefore(other)/isAfter(other); // e.g. a.isBefore(b); // Date and timeNEWLINEpublic long until(Temporal endExclusive,  TemporalUnit unit) //  e.g. date1.until(date2, ChronoUnit.DAYS)); // Days between 1 & 2NEWLINEChronosUnit.MINUTES.between(timeOne, timetwo); // Minutes between...
58,Get date elements [4],.getDayOfWeek(); MONDAY // Returns EnumNEWLINE.getMonth(); JANUARY // Returns EnumNEWLINE.getYear(); 2020  NEWLINE.getDayOfYear(); 20
59,Notes [2],If catch and finally both throw an exception the one from the finally get throughNEWLINERethrowing Exception: When you write Exception e in the catch statement, java assumes catch the exception that the method throws
60,Create exceptions [2],Extend Exception or RuntimeExceptionNEWLINEConstructors (No argument, Exception e, String message)
61,Multi catch [3],Use | but only one eNEWLINEMeant to catch unrelated exceptions NEWLINEDo not reassign a new exception to e // As compiler doesn't know which one it's going to be
62,Try with resources [7],try (MyClass c = new MyClass()) { c.doSometh(); } NEWLINEResources are closest in reverse order after the try statements ends, after which catch and finally are run!NEWLINEImplements AutoCloseable (there's also a thing called Closeable, which also works)NEWLINEImplement close() methodNEWLINERecommended that close throws specific or no exceptionsNEWLINEIf close is able to throw an exception, a catch statement is required NEWLINEClosable only allow to throw IOException
63,Suppressed Exception [2],Multiple exceptions, only the first is 'active' the rest are suppressedNEWLINEfor (Throwable t : e.getSuppressed()) { t.getMessage(); }
64,Assertion - When you expect a boolean expression to be true [3 forms],assert i > 0; NEWLINEassert(I>0); NEWLINEassert i > 0: "OhNo!" // Look for colon! Any value or Supplier
65,Files reading writing [4],Files.newBufferedReader(p); NEWLINEFiles.newBufferedWriter(p); // Use try with resources, catch IOExp for reader/writer methodsNEWLINEFiles.readAllLines(p); // IOExcept list<String>  // Not a stream, memory intensive // IOExceptNEWLINEFiles.lines(p); // IOExcept Stream<String> // Better than readAllLines(); Creates Stream<String> loads one bit at a time // IOExcept
66,File Attributes (specific to NIO.2) [9 methods],Files.isDirectory(); // Has to exist, can refer to symbolic linkNEWLINEFiles.isRegularFile(); NEWLINEFiles.isSymbolicLink();NEWLINEFiles.isHidden(); // Catch IOException eNEWLINEFiles.size(); // Instead of .length(); !!NEWLINEFiles.getLastModifiedTime(); NEWLINEFiles.setLastModifiedTime();NEWLINEFiles.getOwner(); NEWLINEFiles.setOwner();
67,Walking and Searching using Files [3 methods],Java, lazy, depth first. Avoid circular paths, throws FileSystemLoopExceptionNEWLINEStream<Path> Files.walk(path). May throw error when missing access permission. NOFOLLOW_LINKS is defaultNEWLINEAlso goes through subdirectories
68,Views [4 methods],Faster for multiple attributes; Fewer trips; Adapts to file systemNEWLINEView creationNEWLINEBasicFileAttributes data = Files.readAttributes(path, BasicFileAttributes.class); // Cannot modify, watch for questions!NEWLINEBasicFileAttributeView.class // Can also alter
69,View access [4],data.isOther(); NEWLINEdata.lastAccessTime(); NEWLINEdata.creationTime(); NEWLINEdata.fileKey();
70,Connection [3],conn.setAutoCommit(boolean)NEWLINEconn.commit(); // Commits all previous NEWLINEconn.rollback(); // Cancels all(!)previous statements
71,Statement [4 methods],e.g. Statement stmt = conn.createStatement(ResultSet.YPE_SCROLL_INSENSITIVE, ResultSet.CONCU_READ_ONLY);NEWLINEbool b = stmt.execute() // Can alter; Cannot return data; Boolean; true for select; false for alterationNEWLINEResultSet rs = stmt.executeQuery() // Cannot alter: Can return ResultSet (Running another query closes first rs!)NEWLINEstmt.executeUpdate() // Can alter; Return nr (int) rows changed
72,Reading ResultSet [9 methods],while(rs.next()) { int id = rs.getInt(“id”); }NEWLINE.getBoolean(); .getInt(...); .getDouble(); .getLong(); // Int not spelled in fullNEWLINE.getString(...); .getObject();NEWLINE.getData(); .getTime(); .getTimeStamp(); // java.sql.Date/Time/TimeStampNEWLINEArgument is column label or number; Numbers start at 1 not 0;NEWLINESQL Date Conversion [2]NEWLINEjava.sql.Date sqlDate = rs.getDate(1);NEWLINELocalDate localDate = sqlDate.toLocalDate(); // This is a method not a factoryNEWLINEJDBC Date and Time [3]
73,SQL Date Conversion [2],java.sql.Date sqlDate = rs.getDate(1);NEWLINELocalDate localDate = sqlDate.toLocalDate(); // This is a method not a factory
74,JDBC Date and Time [3],java.sql.Date - java.time.LocalDate - Date onlyNEWLINEjava.sql.Time - java.time.LocalTime - Time onlyNEWLINEjava.sql.TimeStamp - java.time.LocalDateTime - Date and Time
75,Scrolling ResultSet [8 methods],void afterLast(); void beforeFirst(); // Surprisingly these return void. Watch for questions on this!NEWLINEboolean first(); boolean last(); boolean next(); boolean previous() // Spelling in full!NEWLINEboolean absolute(int rowNum); boolean relative(int rowNum); // Negative numbers start from end. absolute(0) = false;NEWLINEClosing Database ResourcesNEWLINETry (Connection conn = DriverManager.getConnection(url);	….);NEWLINEThe ‘old’ way uses a finally block and lots of checks to see what still is open. NEWLINEExceptionsNEWLINEcatch(SQLException e) { e.getMessage(); e.getSQLState(); e.getErrorCode(); }
