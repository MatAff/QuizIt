Java programming - ocp
Question Checklist
Are all ; in place?
Check are the correct () [] {} being used?
Is everything spelled correctly?
Check are the relevant exceptions being caught?
Answer the question
Notes
Underlined lines throw exceptions
[...] numbers indicate number of methods/points to remember

Chapter One - Advanced Class Design

Instanceof [4]
myObject instanceof Class
Comparing unrelated classes does not compile
Compare to null returns false
Instance can be compared to all interfaces as a subclass could implement
Equals [2 notes]
Reflexive (a to a > true); Symmetric(a to b = b to a); Transitive (if a to b & b to c then a to c); Consistent (a to b = a to b) 
Comparison to null >> false
Equals steps [4]
Input Object obj; 
Check instance of; (Can also be used to compare arrays)
Cast and compare
Return primitive boolean
hashCode [3 notes]
obj.hashCode();
Use ‘fixed’ variables. E.g. don't use weight which could change
When equals is true, hashcode should be same

Enums 
Enum methods [4]
s.name () // Returns value
s.ordinal () // Returns position as int
Season.valueOf("Summer"); // Returns Enum constant
Season.values() // Returns array of values
Enum basics [3]
enum Season { WINTER, SUMMER }; Upper case is convention
Semicolon compulsory when more than values and field values are listed 
Try to keep enums simple
Enum usage [7]
Do not extend, but can implement an Interface
Do not compare to int; 
Can use in switch, but use SUMMER, not Season.SUMMER!
Can be private
Can not be members, but not local
Can be printed directly // Prints SUMMER, not Season.SUMMER
Boolean.False // Works, is a thing..
Enum advanced [2]
Can add state SUMMER (“warm”) also add field and private or default (!) constructor (not protected or public), field may be public!
Or assign method to each value and use overall abstract or default method. e,g WINTER { public void doSometh() { ..} }, SUM...
Inner/Nested Classes
Member inner classes [6]
Can be public, private, protected or default
Can be abstract or final
Cannot declare static members
Compiling creates two .class files e.g. Outer.class & Outer$Inner.class
Have access to all members of enclosing class using Outer.this.member, or Level1.Level2.this.m or Level2.this.m
Instantiated using new Outer.new Inner(); or outer.new Inner(); // Can't be instantiated directly from static (!) main method!
Local inner classes - Declared in method [4]
Same as member inner except: 
No access specifier (as already local to the method). Cannot be static
Only have access to local variables if effectively final
Can be instantiated within method using new Inner, without object of outer class
Anonymous inner class [5 - 3 notes]
Does not get name, just body
Extends existing class or implements interface 
Ends in semicolon! Watch out for this! 
abstract class MyAbs{ abstract void doSometh(); } // The abstract class without method implementation
MyAbs anno = new MyAbs() { void doSometh() { [implementation] } }; // Create anonymous class with implementation
Static nested classes [6]
Can be instantiated without objects of enclosing class
Cannot access members of enclosing class without explicit object
Can be private, etc
Static nested classes can be imported using either import static or normal import
import static bird.Toucan.Beak;
Can be extended by concrete (non-static) member/inner classes.
Ch01 - Other [9]
Abstract classes can extend concrete classes
If you overwrite the public String toString method, that will get called when printing object
Virtual method invocation - Implementation depends on class
Annotation - @Override - indicates a method is being overwritten 
Remember all inteface methods are public
Static initializer run even when the class is not initialized
System.out.println(); // Without argument print blank line
Invariant property of an object - A property that remains true regardless of how the object is modified.
Variable accessed from static location, must be static; not assigned at declaration >> can't be final

Chapter Two – Design Patterns - Done
Functional interface - @FunctionalInterface [2 notes]
Contains exactly one abstract method, which it may contain through inheritance
May contain other static/default methods
Lambda Rules [6]
If more than one variable parentheses are required
If input variables are declared all must be declared and parentheses are required
When return keyword is used {} are required
When {} are used ; is required
Variables must be initialized if used (don't get default values)
Has access to final members, and cannot reuse the same identifiers
Lambda Syntax Examples [5]
a OR (Animal a) OR () OR (Animal a, Duck d) OR (a,b) OR ()
NOT: (int x, y) // Both must be declared
a.canHop() OR { return a.canHop(); } OR new Duck() OR {} OR {return;} OR { int x = 0; return 5; }
NOT: (int x) -> { int x = 0; return 5; } // Can’t redeclare (i.e. x)
NOT: () -> {int x; return x >0; } // Variables must be initialized if used!
Polymorphism [5]
The reference determines which properties are available
The object determines the behavior
Methods always call the instance variables available in the object // !!!
Static methods behave depending on reference
Variables behave like static methods
Design Principles - Established idea/best practice. General solution to common problems [7 - 4 notes]
Encapsulating: private fields with public getters and setters
JavaBeans; Properties are private; get, set, is (optional for Boolean)
is-a; has-a
Composing object
Create object from smaller pieces such as arms and legs
These pieces can be instantiated in the constructor
This way the pieces can be reused elsewhere
Design pattern: Singleton [5, 3 important pieces]
Private constructor - private SingletonName() {}
Private static final member/instance - private static final SingletonName instance = new SingletonName();
Accessed using public static method - public static SingletonName getInstance() { return instance; }
Single shareable instance; Used by multiple instances; Faster data loading
Because the constructor is private, the singleton class becomes effectively final, because a subclass constructor won't be able to call super();
Design pattern: Singleton with Lazy instantiation [3 points]
Check is instance==null in get Instance
instance is not final
Is not thread safe unless marked as synchronized
Design pattern: Creating Immutable objects [5]
Use constructors to set all properties
No setters
Mark instance variables private and final
Don't allow access to mutable objects (return copies instead, or use Collections.unmodifiableList())
Prevent overwriting of methods ((mark class OR methods final) OR mark the constructor private and use a factory pattern)
Other Design Patterns
Design pattern: Builder pattern [3]
Separate class to set and build instance
Tightly coupled
Sometimes static inner class, can call private constructor
Design pattern: Factory pattern [1]
Calls relevant class based on e.g. the animal name in switch statement
Read book design patterns, 1994
Chapter Three – Generics and Collections - Done
Generics - No type
Conventions: E – Element; K – Map key; V – Map value; N – Number; T – Generic data type
Gets converted to object plus cast behind the scenes (type erasure)
What you can’t do:
new T()
Create an array of that static type
Call instanceof
Use a primitive type
Create a static variable as a generic type parameter
Generic Methods [4 notes]
Useful for static methods, where the generic isn't determined by the class
public static <T> void methodName(T t) ()
public static <T> T methodName(T t) ( return t; ) // Extra T required as method returns something
Can be called using: ClassName.<String>methodName(s); // Complicated but valid, <> not required
Bounds - Allows methods to accept lists of limited types [4]
List<?> list = ..
Upper bound: <? extends Number>; Number of anything that extends Number
Lower bound: <? super String>; String or super classes of // This is the only one you can add element to directly!
Use as reference only; Can only add elements directly to ? super ...
Collections [6]
List: ordered collection; May contain duplicates; Access by index
Set: No duplicate entries
Queue: Has order; Typically first in-first out, other orderings possible
Map: Keys to values, no duplicate keys
Can’t be null: When sorting is involved (everything that is labelled 'tree'); ArrayDeque; Hashtable
Can be printed directly using System.out.println();
Common collection methods [6]
boolean add(E element); 
boolean contains(Object object); 
boolean remove(Object object);
int size(); 
void clear(); 
boolean isEmpty(); 
List
ArrayList; LinkedList; Vector
List: Adding, getting, setting, removing [5]
void add(E element); List<Object> l.add(123); // Works because Integer is also a number and also an Object
void add(int index, E element); 
E get(int index); 
E set(int index, E e)	// Replaces and return original
void remove(int index); // Different from common method, this takes primitive!
List: Index [2]
int indexOf(Object o); // Find first; -1 if not found
int lastIndex(Object o); // Find last; -1 if not found
Old List Looping Method [1, 3]
Iterator iter = list.iterator(); while(iter.hasNext()) { String string = (String) iter.next(); } // hasNext >> next


Set - No duplicates [2]
HashSet - Uses HashCode to quickly retrieve - No sorting
TreeSet - Has order - Sorts - Needs to implement Comparable
No extra methods
TreeSet - Implement NavigableSet interface [4 methods]
E lower(E e) // < e; E floor(E e) // <= e; E ceiling(E e) // >= e; E higher(E e) // > e // or returns null
lower < floor <= e <= ceiling < higher

Queue [3 types, 8 methods]
ArrayDeque; LinkedList; Stack;
FIFO (most common); ArrayDeque: offer > peek > poll
LIFO; Stack: push > peek > pop
Queue: Adding [3]
boolean add(E e); // Adds element to the back, returns true or throws exception
boolean offer(E e); // Adds element to the back, returns true/false [ArrayDeque]
void push(E e); // Adds element to start, makes it a double ended queue
Queue: Peeking [2]
E peek(); Returns next element or null if empty [ArrayDeque, Stack]
E element(); // Returns next element, throws exception if queue is empty
Queue: Removing [3]
E poll(); Removes and returns next element or null if empty [ArrayDeque]
E remove(): Remove and returns next element or throws exception
E pop(); // Removes and returns next element, throws exception if empty
Stack methods [3]
void push(E e); // Adds element to the front of the queue. This makes it a double ended queue [ArrayDeque, Strack]
E pop(); // Removes and returns next element, throws exception if empty
E peek(); Returns next element or null if empty [ArrayDeque, Stack]

Map - Has value and key [3, 2 types, 10 methods]
TreeMap – In order of keys; 
Hashtable – No predictable order; HashMap
Doesn’t extend Collection
Methods 
Map: Putting, getting and removing [4 - 3]
V put(K key, V value) // Adds or replaces key/value pair. Returns previous value or null. Adding the same key overwrites, does not throw an Exception!
V get(Object key) // Returns values based on key
V remove(Object key) // Returns null if not found'
There is not Add method!
Map: Common methods [3]
int size(); 
boolean isEmpty(); 
void clear() // Removes all keys and values
Map: Contains [2]
boolean containsKey(Object key); 
boolean containsValue(Object); // There is no .contains() method
Map: Keys and values [2]
Set<K> keySet() // Returns keys e.g. map.keySet();
Collection<V> values() // Returns values e.g. map.values();




Sorting [1]
Sorting Order: [0-9][A-Z][a-z]
Comparable [7] 
class MyClass implements Comparable<MyClass> // Comparable using generics
Interface - implement compareTo method 
id – a.id sorts ascending. e.g. this - that
Return: Zero when equal; < 0 - this object is smaller; > 0 - this object is greater
Strongly recommended that compareTo() and equals() are consistent
Legacy code uses object as input and thus requires casting before comparison
Comparable is a functional interface, no sense to implement using lamba, as the purpose is the implement inside the object being compared
Comparator [5]
Separate class<> that allows for sorting by different variables 
Could implemented as inner class
Method: compare
Method can be implemented using lamba
Can be used to implement multiple fields



Package
In class
Method
Nr Parameters
Lambda
Comparable
java.lang
Yes
compareTo
1
No
Comparator
java.util
No
compare
2
Yes
 
Searching and Sorting [2]
Collections.sort(myElements) expects elements to implement Comparable otherwise fails to compile
Collections.sort(myElements, myComparator) Alternative using Comparator

Method References using :: [3]
System.out::println // Will infer argument - No ()!
Comparator<Duck> byWeight = DuckHelper::compareByWeight; // Replaces the below…
Comparator<Duck> byWeight = (d1, d2) -> DuckHelperbhai.compareByWeight(d1, d2);

Collection methods/iterators? [9, 6 methods]
list.removeIf(s -> s.startsWith("A"));
list.replaceAll(x -> x*2);
list.forEach(System.out::println); // Only takes Consumer<>, no variations!
map.computeIfPresent 
map.computeIfAbsent
map.merge(someKey, someAltValue, BiFunction); [3]
Key already in map: Result of function
Key not in map: Value added
Function returns null for existing value: Remove
Chapter Four - Functional Programming
Standard Interfaces [8]
Functional Interface
# Parameters
Return Type
Method
Supplier<T>
0
T
get
Consumer<T>; BiConsumer<T, U>
1(T); 2(T, U)
void
accept
Predicate<T>; BiPredicate<T, U>
1(T); 2(T, U)
boolean (primitive)!
test
Function<T, R>; BiFunction<T, U, R>
1(T); 2(T, U)
R
apply
UnaryOperator<T>; BinaryOperator<T>
1(T); 2(T,T)
T
apply

Standard Interface Notes [5]
Arguments listed as: Input, Input, Output
If generic is missing Object is assumed
Predicate<Integer> p1 = i -> i > 0, p2 = p1.negate(); // Multiple can be assigned on one line
Consumer<String> prt = System.out::println; // Assign method reference to interface 
Predicate<Integer> belowZero = i -> i < 0; Predicate<Integer> above = belowZero.negate(); // Negate existing predicate
Optionals
Optional - Creating [3]
Optional.empty();
Optional.of(...); // Create optionals, cannot use null
Optional.ofNullable(...); // Can handle null
Optional - Reading [7, 8 methods]
opt.get(); // Throws NoSuchElementException (RunTime)
boolean opt.isPresent(); 
opt.ifPresent(Consumer c); 
opt.orElse(T other); // Returns other value if none present
opt.orElseGet(Supplier S); // Supplier only
opt.orElseThrow(Supplier S) // Throws specified exception if no value e.g. opt.orElseThrow(() -> new RuntimeException()));
Also has methods: filter(P), map(F/U)
Streams
java.util.stream.*;
Create Streams [6 ways]
Stream<String> empty = Stream.empty(); 
Stream.of(1, 2, 3); // From data
Stream<String> fromList = list.stream();  // Don't do this on Map
list.parallelStream(); // From list (sorting does not affect original list)
Stream<Double> randoms = Stream.generate(Math::random); 
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); 
Stream.concat(s1, s2); // Create stream from two streams; Becomes parallel if one of them is parallel.
Intermediate Operations [8 - 9 methods]
.filter(Predicate)
.distinct()  // Removes duplicates, using equals
.limit(int)  
.skip(int)
.map()  // Uses Function, or UnaryOperator
.flatMap() // Always produces a non-parallel stream, requires lamba, (to convert to stream)
.sorted(); .sorted(Comparator); // Note Comparator.reverseOrder(), not Comparator::reverseOrder
.peek() // Doesn't change stream
.parallel() // Create parallel stream from stream
Terminal Operations [10, 3-2-3-1-1-3 = 13]
long count(); Optional<T> min(); Optional<T> max(); // Reductions; Returns Optionals! min, max need Comparator arg
These is no sum(); // Only exists for primitive streams
findAny(); findFirst(); // Returns Optional<T>, these are not reductions, they don't take arguments. Returns Optionals!
allMatch(); anyMatch(); noneMatch(); // boolean or runs forever
forEach(); forEachOrdered(); // Second is for use with parallel streams
Collect: Stream.of("h","i","g","h").collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
Reduce: Stream.of("h","i").reduce("", (s, c) -> s + c); // Used BinaryOperator or BiFunction [3]
2 arg > Object; start value + accumulator
3 arg > Object; start value + accumulator + combiner > Most useful for parallel stream
1 arg > Optional, as may be empty! Collector
Printing a stream [3]
s.forEach(System.out::println); // Print using forEach
s.peek(System.out::println).count(); // Print using peek, remember to add a terminal operation
System.out.println(s.collect(Collectors.toList())); // Convert to list and print
Primitive Streams [3 types, 4 methods]
IntStream; LongStream; DoubleStream; // Watch spelling
IntStream.range(1,6); IntStream.rangeClosed(1,5);
DoubleStream.generate(Math::random); DoubleStream.iterate(0.5, d -> d / 2);
Functions to convert different stream type [3]
To same always map, i.e. can't call others on self!
Steam = mapToObj; DoubleStream = mapToDouble; IntStream = mapToInt; LongStream = mapToLong
Watch out for mapToBool nonsense!
Interface to use as parameter in those map... functions [2]
StartToEnd e.g. IntToLongFunction, ToLongFunction
SelfUnaryOperator e.g. DoubleUnaryOperator (stream to stream is just Function)
Functional interfaces for double, int, long [5, 3x6]
Double/Int/Long  Supplier/Consumer/Predicate/Function<R>/UnaryOperator/BinaryOperator 
Return generic is specified for Function, and only for Function!
methods often renamed to reflect type (not for Consumer, Predicate, Function)
There's no BiConsumer, BiPredicate, BiFunction (only BinaryOperator)
BooleanSupplier also exists
Conversion Interfaces To and Between Primitive Streams [3x2,3;3x3,3;4x1]
ToDouble/ToInt/ToLong Function<T>/BiFunction<T,U> // applyAs Double/IntLong
Double/Int/Long To Double/Int/Long Function // applyAs Double/IntLong
Obj Double/Int/LongConsumer<T> // Accept, note generic parameter // Takes Object and primitive
Primitive Optionals
Optional with primitive streams [2]
OptionalDouble; OptionalInt; OptionalLong
e.g. stream.average(); // Returns OptionalDouble
Primitive optional methods [2, 4]
Getting as primitive: getAsDouble(); getAsInt(); getAsLong();
.orElseGet(Double/Int/LongSupplier);
Primitive stream stats [3]
.max(); returns OptionalDouble/Int/Long;
.sum(); returns double/int/long;
.average(); // Always return OptionalDouble, not written in full >> Actually it is written in full! (Double check in book)
Summary Statistics [5]
IntSummaryStatistics stats = ints.summaryStatistics(); // Written in full!
stats.getMax(); 
stats.getMin();
stats.getAverage(): // Apparently returns Double and not Optional<Double> (different from above)
IntSummaryStatistics incomeStats = Employee.persons() .stream()
        .collect(Collectors.summarizingInt(Employee::getIncome));
Advanced Stream Pipeline Concepts [1]
If a stream is created based on a list, and an element is added to the list, that element will still be part of the stream.
Collecting Results (10)
.collect(Collectors.toList(); // There's no toArrayList()! 
.collect(Collectors.toCollection(ArrayList::new)); .collect(Collectors.toCollection(new ArrayList()));
.collect(Collectors.toSet()); .collect(Collectors.toCollection(TreeSet::new));
.collect(Collectors.joining(", ")); // Or no arg
.collect(Collectors.groupingBy(); .collect(Collectors.partitioningBy(predicate)); // Result: { false=[...], true=[..., ...] }
.collect(Collectors.averagingInt(String::length));
.collect(Collectors.toMap(s -> s, String::length));
.collect(Collectors.toMap(String::length, k -> k, (s1, s2) -> s1 + ", " + s2));
.collect(Collectors.toMap(String::length, k -> k, (s1, s2) -> s1 + ", " + s2, TreeMap::new));
Chapter Five - Dates, Strings, and Localization
Date and Time - Basics[4]
import java.time.*;
Remember, Date and Time are created using factory static methods
Daylight Savings Time - Java is smart enough to adjust for this
2016-08-28T05:00-07:00: Do 5 + 7 to get GMT time 12
DateTime - Classes [1 - 4 types]
LocalDate; LocalTime; LocalDateTime; ZonedDateTime 
DateTime - Create [7 - 6]
LocalTime.now() 
LocalDate.of(2015, Month.JANUARY, 31)
ZonedDateTime.of(2015,1,20,6,15,30,200,zone); // No option to pass in Enum for month in this one
ZonedDateTime.of(localDate, localTime, zone); // Better
ZoneId zone = ZoneId.of(“US/Eastern”);
ZoneId.systemDefault();
RunTime Exception: DateTimeException could be thrown if invalid numbers are passed in
To Epoch [3]
long LocalDate.toEpochDay()
long Local/ZonedDateTime.toEpochSecond()
Neither exist for Time only classes
Instants [4, 3 methods]
Specific moment in time based on GMT
Instant.now()
zonedDateTime.toInstant(); // Not just DateTime has to have zone info too
Instant.ofEpochSecond(long);
instant.plus(nr, ChronoUnit); // Unit has to be days or smaller
Manipulating Dates and Times [4 - 2x8+2, 2 notes]
.plus/minusYears, Months, Weeks, Days, Hours, Minutes, Seconds, Nanos
.plus/minus(period); 
Can be strung together; Can only be applied to the logical classes
Periods [4 - 5 methods, 3 notes]
Period.ofYears(); .ofMonths(); ofWeeks(); ofDays(); of(year, month, day);
Don't string together, only last one will apply
Not for time
P1Y2M3D or P21D // when printing
Duration [5, 7 methods, 2 notes]
Duration.ofDays(); .ofHours(); .ofMinutes(); .ofSeconds(); .ofMillis(); .ofNanos(); 
Duration.of(1, ChonosUnit.Days); Units: HOURS, MINUTES, SECONDS, MILLIS, .NANOS; 
Only one unit at a time, don't string together, only last one will apply. There's also ChronoUnit.HALF_DAYS
For time (and days)
PT1H, PT10S // Example of when printing; PT60S == PT1M
Comparing [3]
bool this.isBefore(other); this.isAfter(other); // Date and time
public long until(Temporal endExclusive,  TemporalUnit unit) //  e.g. date1.until(date2, ChronoUnit.DAYS)); // Days between 1 & 2
ChronosUnit.MINUTES.between(timeOne, timetwo); 
Duration.between(now, later); duration.toMillis();
Formatting Dates and Times
Get date elements [5]
.getDayOfWeek(); MONDAY // Returns Enum
.getMonth(); JANUARY // Returns Enum
.getYear(); 2020  
.getDayOfYear(); 120
.getDayOfMonth(); 20
DateTimeFormatter [2]
import java.time.format.*;
Only  call on appropriate data types, but Time can be called on dateTime.
Date format directly [3]
date.format(DateTimeFormattter.ISO_LOCAL_DATE); 2020-01-20
time.format(DateTimeFormattter.ISO_LOCAL_TIME); 11:12:34
dateTime.format(DateTimeFormattter.ISO_LOCAL_DATE_TIME); 2020-01-20T11:12:34
Create DateTime formatter [2]
DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT); // Only Date
DateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT); // Only prints time
DateTime can be either object of parameter [2]
shortDateTime.format(dateTime); // 1/20/20 (Date piece only)
dateTime.format(shortDateTime); // Equivalent!
DateTime Format styles [3]
FormatStyle.ISO_LOCAL_DATE/_TIME_DATE_TIME // 2020-01-20T11:12:34
FormatStyle.SHORT // 1/20/20 11:12 AM
FormatStyle.MEDIUM // Jan 20, 2020 11:12:34 AM
Date time pattern [8]
FormatStyle.ofPattern(“MMMM dd, yyy, hh:mm”); // Can throw runtime exception, with non usable pattern
yyyy - year: yy = 16, yyyy = 2016
MMMM - Month: M = 1, MM = 01, MMM = Jan, MMMM = January // Month is the only one using capitals
dd - date: d = 1, dd = 01
hh - hour: h = 1, hh = 01
mm - minute: m, mm
, = ,   : = :
.parse(“01 02 2015”, f); // First String, then formatter
Formatting
Formatting Numbers [7, 5 methods, 2 notes]
java.text.*;
en = NumberFormat.getInstance(Locale.US); // Or no argument
en = NumberFormat.getNumberInstance(...);
en = NumberFormat.getCurrencyInstance(...);
en = NumberFormat.getPercentInstance(...);
en = NumberFormat.getIntegerInstance(...);
en.format(someValue);
en.parse(someString); Converts string to number using NumberFormat. Gives error when string does not start with number
String Recap
Common String methods [11]
String state method [3 - 7 methods]
.isEmpty(); .length()
.charAt(4); .indexOf('e'); .indexOf("de")
.startsWith("a"); .contains("ll")
String alteration methods [4]
.trim()
.substring(2,4)
.toUpperCase(); .toLowerCase();
.replace('a','1')
Internationalization and Localization [3]
Internationalization: The process of designing a program such that it can be adapted.
Localization: Actually supporting multiple locales.
Locale: A specific geographical, political or cultural region
Creating Locale [8 - 6 methods]
Locale locale = Locale.getDefault();  // en_US
new Locale(“fr”); new Locale(“hi”, “IN”); // Capitalization matters
Locale l1 = new Locale.Builder()
    .setLanguage(“en”) // Capitalization does not matter
    .setRegion(“US”)
    .build();  // Uses builder design pattern
Locale.setDefault(new Locale(“fr”)); // Overwrites default
Locale.GERMANY 
Properties File [4]
Zoo_en_US.properties
hello=Bonjour OR animal:dolphin OR animal dolphin 
// # or ! are used for comments in resource files
Can end line with \ if that helps clarity
Load Properties into ResourceBundle [3]
ResourceBundle rb = ResourceBundle.getBundle(“Zoo”, new Locale(“en”)); // Locale optional
rb.getString("key"); // No default value allowed; null if key not found
rb.keySet(); 
Properties Functionality [4]
Properties props = new Properties();
rb.keySet().stream().forEach(k -> props.put(k, rb.getString(k)));
.getProperty("key", [optional] "default"); // Default value is returned if property is not found
.get(); // No default value allowed
Java Class Resource Bundle [5]
Actual java file e.g Zoo_en_US.java
extends ListResourceBundle 
protected Object[][] getContent { return new Object[][] { {"key","value"} }; } 
rb.getObject("key");
Can use other types than String
Bundle order [7]
.java before .properties 
First drop country
Then drop language
Then default local
Default local based on language only
Then default bundle
Finally MissingResourceException (RunTime)
Parent bundles [2]
If not found, java can look in parents. Remove elements till you get to the top
e.g. Zoo_fr_Fr.java >> Zoo_fr.java >> Zoo.java // Note: does not switch to .properties or Zoo_en even if that's the default Locale
Chapter Six Exceptions and Assertions
Notes [3]
If catch and finally both throw an exception the one from the finally get through
Rethrowing Exception: When you write Exception e in the catch statement, java assumes catch the exception that the method throws
You can't catch an exception that's not throwable (as declared in the method signature), but you can say you could throw something (in the method signature) without actually being able to do it. Keep watching for these!
Throwable is considered a checked exception
Create exceptions [2]
Extend Exception or RuntimeException
Constructors (No argument, Exception e, String message)
Multi catch [3]
Use | but only one e
Meant to catch unrelated exceptions 
Do not reassign a new exception to e, as compiler doesn't know which one it's going to be
Try with resources [5]
Resources are closest in reverse order after the try statements ends, after which catch and finally are run!
Implement AutoCloseable or Closeable, overwrite close() method
Closable only allow to throw IOException
Recommended that close throws specific or no exceptions;If close is able to throw an exception, a catch statement is required 
e.g. try (MyClass c = new MyClass()) { c.doSometh(); } 
Suppressed Exception [2]
Multiple exceptions, only the first is 'active' the rest are suppressed
for (Throwable t : e.getSuppressed()) { t.getMessage(); }

Assertion [6]
assert i > 0; assert(I>0); assert i > 0: "OhNo!" // Look for colon! Any value or Supplier
Throws java.lang.AssertionError if not true
By default assertions are ignored by java; Needs to run with assertions enabled using java -enableassertions or java -ea
java -ea:sample.package... // Limit to package and subpackages
java -ea:sample.package.MyClass -da // Limit to class (does not matter that -da comes after ea
Keep an eye for question with assert without assertions enable, those will run!
Chapter Seven Concurrency
Daemon thread: Will not prevent JVM from exiting
Thread.MIN_PRIORITY; .NORM_PRIORITY; .MAX_PRIORITY
Concurrent Interfaces [2]
Runnable - void run(); // For action; No return, no exceptions
Callable<T> T run(); // For tasks; Returns generic and throw Exceptions
Create thread [10]
implements Runnable (preferred)
    Overwrite void run()	
    In main  (new Thread(new MyClass))).start();
    Pros: Allow you to extend other classes; Better OO design
extends Thread
    Overwrite void run()
    In main (new MyClass()).start();
    Pro: potential to set priority
ExecutorService
Beware of cases where run is called instead of start, as those run on the same thread
Polling with Sleep [2]
Check whether thread has finished, include Thread.sleep(...); To prevent constant checking.
Deal with InterruptedException 
ExecutorService [7, 5 types]
Import java.util.concurrent.*;
Obtain through Executors Factory class
                 ExecutorService service = Executors.newSingleThreadExecutor();
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
                 ExecutorService service = Executors.newCachedThreadPool();
                 ExecutorService service =  Executors.newFixedThreadPool(int nThreads);
ScheduledExecutorService service = Executors.newScheduledThreadPool(int nThreads);
Executor service method [6]
service.execute(Lamba Expression);
Add try/finally { if(service!=null) service.shutdown();
isShutdown() // true after .shutdown() called
service.awaitTermination(long timeout, TimeUnit unit);
isTerminated() // true after remaining threads have finished running
shutdownNow() // Attempt to stop all running tasks. Returns List<Runnable> with non-finished tasks
Submitting tasks [5]
void execute(Runnable command); // Runnable only
Future<?> submit(Runnable task);  f.get(); >> null (Runnable doesn't return anything)
<T> Future<T> submit(Callable<T> tasks); // Runnable or Callable
<T> List<Future<T>> invokeAll(Collection<? Extends Callable<T>> tasks) throws InterruptedException
<T> T invokeAny(Collection<? Extends Callable<T>> tasks) throws InterruptedException, ExecutionExpection
Future methods [6 - 5 methods]]
boolean isDone(); // Is the task complete
boolean isCancelled()
boolean cancel()
V get(); // Return null for Runnable // has Exceptions that need to be caught!
V get(long timeout, TimUnit unit) // In addition has timeoutException
The future itself contains a reference e.g. java.util.concurrent.FutureTask@12ec34e which can be printed.
Scheduling Tasks [5 - 4 methods]
schedule(Callable<V> callable, long delay, TimeUnit unit);
schedule(Runnable command, long delay, TimeUnit unit);
scheduleAtFixedRate() // Runnable, 4 agrs
scheduleAtFixedDelay // Runnable, 4 agrs
Time units; TimeUnit.NANOSECONDS .MICROSECONDS .MILLISECONDS .SECONDS, .MINUTES, .HOURS, .DAYS

Data Management
Atomic Classes [4. 7]
AtomicBoolean
AtomicInteger; AtomicIntegerArray
AtomicLong; AtomicLongArray
AtomicReference; AtomicReferenceArray
Atomic Methods [2, 7]
get(); set(); getAndSet()
incrementAndGet(); getAndIncrement(); decrementAndGet(); getAndDecrement();
Synchronized [3]
synchronized(object/this/etc) // Needs something to synchonize e.g. (this) or a method
private synchronized void methodName(); // Method
Cannot be applied to variables
Concurrent Collections [10]
CopyOnWriteArrayList // Makes copy when written to, can be altered in loop
CopyOnWriteArraySet // Makes copy when written to, can be altered in loop
ConcurrentSkipListSet // SkipList => tree => sorted - TreeSet
ConcurrentLinkedQueue
ConcurrentLinkedDeque
LinkedBlockingDeque
LinkedBlockingQueue
ConcurrentHashMap
ConcurrentSkipListMap // SkipList => tree => sorted - TreeMap
e.g. Collections.syncronizedList(new ArrayList<>(Arrays.asList(1,2,3)));
Blocking Queues [4 - 6]
offer(E e, long timeout, TimeUnit unit); // Or without the timeout part
poll(E e, long timeout, TimeUnit unit) // Returns E e?
offerFirst; offerLast; pollFirst; pollLast;
Needs catch(InterruptedException e);
Obtaining Synchronized Collections [9 - 8 methods, 1 note]
synchronizedCollection(Collection<T> c)
synchronizedList(List<T> list)
synchronizedMap(Map<K,V> m)
synchronizedNavigableMap(NavigableMap<K,V> m)
synchronizedNavigableSet(NavigableSet<T> s)
synchornizedSet(Set<T> s)
synchronizedSortedMap(SortedMap<MK,V> m)
syncrhonizedSortedSet(SortedSet<T> s)
Don't modify while iterating over these, this will lead to ConcurrentModificationException
Parallel Streams [12, 2 to create, 3 terminal operations]
stream.parallel(); 
list.parallelStream();
Avoid stateful lambda expressions: Where results depends on state that might change during execution
.forEachOrdered();
.findFirst(), .limit(), .skip() // Are performed in an ordered fashion and are slower
.unordered() // Tells java order doesn't matter
parallel reduce() requirements [4 - 3 args]
Identity > Accumulator > Combiner
Identity: must be defined such that .apply(identify, u) is equal to u
Accumulator must be associative and stateless such that (a op b) op c == a op (b op c)
Combiner: must be associative and stateless it aligns with the accumulator
parallel collect() requirements [3]
the stream is parallel
Collector.Characteristics.CONCURRENT
Collector.Characteristics.UNORDERED
CyclicBarrier [4 points]
CyclicBarrier c = new CyclicBarrier(4); // number is threat count to be reached otherwise hangs
Takes second argument (lambda) to print something
c.await(); // Waits for all tasks to finish
Needs catch (InterruptedException | BrokenBarrierException e) {}
ForkJoin Framework - Recursion [6]
java.util.concurrent.*;
Extend
Override compute with if to trigger new task/action
Create ForkJoinTask
Create ForkJoinPool
Start
ForkJoin ExtendExtend [2]
.. extends RecursiveAction - void compute(); // Returns void (like Runnable)
.. extends RecursiveTask<T>  - T compute(); // Returns Generic (like Callable)
ForkJoin Override compute [8]
include if statement
Trigger for new task/actions
Action invokeAll(new SomeAction(), new SomeAction());
ForkJoin Task [4]
Create new task
otherTask.fork();
Do task on this threat  // Very important this is done beween fork and join, other wise single it runs in a single threat manner. 
return thisTaskresult + otherTask.join();
Create ForkJoinTask [2]
ForkJoinTask<?> task = new SomeAction(); // Reference is called task despite being an action
ForkJoinTask<T> task = new SomeTask(); // Enter generic
Create ForkJoinPool [1]
ForkJoinPool pool = new ForkJoinPool();
Start the ForkJoinTask [4]
pool.invoke(task); // No return value for action
Double sum = pool.invoke(task); // Return type for task
Identifying Threading Problems [4]
Liveness: The ability of an application to execute in a timely manner
Deadlock: Two threads are waiting for each other; Can't happen with SingleThreadExe...
Livelock: Occurs when threats are trying to resolve or avoid a deadlock, they appear to be active, but are conceptually deadlocked
Starvation: A threat is unable to get access to the resource it needs
Managing race conditions [2]
Two requests are being submitted at the same time
Ideally: access one, and deny the other (rather than denying both)

Chapter Eight - IO
Streams (the I/O kind) [4 notes]
Byte stream: Use input stream and output stream
Character stream: Use reader and writer; Deals with encoding for you (though both can read character data)
new ObjectInputStream(new BufferedInputStream(new FileInputStream)))
End of ObjectInputStream is detected by catching EOFException
InputStream - OutputStream > Abstract classes Do not instantiate! [3]
FileInputStream - FileOutputStream > Bytes
BufferedInputStream - BufferedOutputStream
ObjectInputStream - ObjectOutputStream > Higher level!
Reader - Writer > Also abstract! Do not instantiate! [3]
FileReader - FileWriter > Characters
BufferedReader - BufferedWriter
InputStreamReader - OutputStreamWriter > Character data from stream
Printers [2]
PrintStream > Writes formatted java objects to binary stream
PrintWriter > Writes java objects to text based output
Flushing: .flush() > Encourage writing to disk; use sparsely; Is called by close(); // For writing to disk, not reading
Closing: call .close() in finally block or use try-with-resource syntax
Marking and reset and Skipping [4]
.markSupported(); // Check support for marking; Watch for question on this, will throw exception!
.mark(int n); // Mark a location for the next n bytes; if not supported throws runtime exception
.skip(numberOfBytesToSkip)
.reset() // Go back to marked location Passing mark read limit may lead to exception when calling .reset()
Serializable [7]
Tagging or marker interface (has no methods)
Class and object within must be marked Serializable or transient (indicating it does not need to be saved)
Throws NotSerializableException (Excepting)
Static variables are ignored (however values may have been retained if objects are serialized and immediately deserialized!)
private static final long serialVersionUID = 1L; // Is stored; Watch for spelling; Recommended, not required
Deserialization may throw ClassNotFoundException
No class constructor or default initializations are used in the deserialization process
PrintStream - PrintWriter - Do not throw exceptions ? [5]
Can open and write to files directly 
PrintWriter can work with OutputStream and format too
System.out and System.err are actually PrintStream objects
.print(); println();
.format(); = .printf();
Interacting with Users
Interacting with users - Old way [4]
import java.io.*;
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
System.in is also a system stream
String userInput = reader.readLine();

Interacting with users - New way: [4]
import java.io.Console;
Console console = System.console(); // Created using singleton pattern
Note console could be null if not available
if (console != null) { String userInput = console.readLine(); }
Console write methods, memorize these! [6]
console.printf();  // Does not need the writer part
console.format(); // Does not need the writer part
console.writer().println; // Needs the writer part
console.writer().print // Needs the writer part
console.writer().write() // Needs the writer part
console.flush(); // Write remaining output immediately; Recommended to call before read commands...
Console read methods [3]
console.reader().read();
console.readLine(); // Without reader()
console.readPassword(); // Remember returns char[]; More secure, avoids use of StringPool, memory can be erased
java.io.File [6]
Can reference both directory and files
Absolute file path vs relative
Use '/' or "\\"
Separator
System.getProperty(“file.separator”));
java.io.File.separator
Methods
File elements [4, 3]
file.getName(); // Return last element
file.getAbsolutePath(); // Adds root
file.getParent() // Returns abstract pathname, or null if parent directory is not named
There is no .getRoot() method
File characteristics [5]
file.exists(); // Non existing >> false
file.isDirectory(); // Non-existing >> false
file.isFile(); // Non-existing >> false
file.length(); // Non-existing >> 0
file.lastModified // Returns number of milliseconds since the epoch, non-existing >> 0
File alterations [4]
file.renameTo(File); // There is no .copy() method 
file.delete(); // returns boolean 
file.mkdir(); 
file.mkdirs()  // Makes directory; mkdirs - including missing parent directories
File listing [2]
.listFiles()	// Returns File[] array
.list(); // Returns String[] array >> Note that this is different from Files.list()!
NIO Alternatives
file.exists(); 	>> Files.exists(path);
file.isDirectory(); 	>> Files.isDirectory(path);
file.isFile(); 	>> Files.isRegularFile(path);
file.length(); 	>> Files.size(path);
file.lastModified(); 	>> Files.getLastModifiedTime(path);
file.renameTo(); 	>> Files.move(path1, path2);
file.delete(); 	>> Files.delete(path); Files.deleteIfExists(path); 
file.mkdir(); 	>> Files.createDirectory(path);
file.mkdirs(); 	>> Files.createDirectories(path);
file.listFiles(); 	>> Files.list(path).map(p -> p.toFile).collect(Collectors.toList());
file.list(); 		>> Files.list(path).map(p -> p.toString).collect(Collectors.toList());
Chapter Nine - NIO.2
Path [8]
import java.nio.file.Path or .*
Path interface
Direct replacement for File
N Stands for Non-blocking
Support for symbolic links (specific to NIO.2)
Refer to file or folder; 
Absolute or relative
Paths: Factory class that can produce Path objects
Path symbols [2]
. = current directory
.. = parent directory
Create Path [5]
Paths.get(String); 
Paths.get(varag String[]); // Overloaded with vararg
Paths.get(URI); // URI (Uniform Resource Identifier) must reference absolute path
file.toPath(); 
FileSystems.getDefault().getPath(...); // FileSystems factory class to create instances
Path methods  [2]
These can be strung together where it makes sense (15 methods)
Immutable: Ensure result is assigned!
Path to methods [3]
path.toFile(); 
path.toURI(); 
path.toString();
Path elements [7]
path.getNameCount(); // Returns the number of elements in the Path
path.getName(int index); // Returns a specific element of the Path as a new Path object; 0 does not refer to root
path.subpath(0.3); // Excludes last nr obviously
path.getFileName(); // Returns Path
path.getRoot(); // Returns Path
path.getParent(); // Returns Path
path.toAbsolutePath(); // Create path starting from root
Path characteristics [1]
path.isAbsolute(); // Does path start from root?
Path manipulate [4]
path1.relativize(path2); // Show how to get to other file. Requires both to be either relative or abstract, otherwise throws error!
path1.resolve(path2); // For joining paths; Running this with an absolute path as argument will return just the absolute path!
path.normalize(); // For cleaning up path symbols; Relative paths do not become absolute
path.toRealPath(); // Checks that file exists, after normalizing. Be sure to handle possible IOException e
Files
Optional Arguments [5]
NOFOLLOW_LINKS: // Don't traverse symbolic links
FOLLOW_LINKS  // Not the default!
COPY_ATTRIBUTES // Also copy metadata. Default!
REPLACE_EXISTING: Overwrite, otherwise exception will be throw is file exists (not the default)
ATOMIC_MOVE: Perform the move in an atomic manner. If not supported a AtomicMoveNotSupportedException could be thrown.
Files - Helper class which takes Path as arguments (12 methods)
Files check methods [2]
Files.exists(path); // Does not throw an exception
Files.isSameFile(p,p); // Throws IOException if either file does not exist or NoSuchFileException
Files alteration [6]
Files.createDirectory(p); 
Files.createDirectories(p);
Files.copy(p,p); // Could take InputStream, path, options..) Can copy to outputstream, which has to go second!
Files.move(p,p);
Files.delete(p); // Throws IOException or RunTime DirectoryNotEmptyException
Files.deleteIfExists(p);  
Files reading writing [4]
Files.newBufferedReader(p); 
Files.newBufferedWriter(p); // Use try with resources, catch IOExp for reader/writer methods
Files.readAllLines(p); // IOExcept list<String>  // Not a stream, memory intensive // IOExcept
Files.lines(p); // IOExcept Stream<String> // Better than readAllLines(); Creates Stream<String> loads one bit at a time // IOExcept
File Attributes (specific to NIO.2) [9 methods]
Files.isDirectory(); // Has to exist, can refer to symbolic link
Files.isRegularFile(); 
Files.isSymbolicLink();
Files.isHidden(); // Catch IOException e
Files.size(); // Instead of .length(); !!
Files.getLastModifiedTime(); 
Files.setLastModifiedTime();
Files.getOwner(); 
Files.setOwner();
Walking and Searching using Files [6, 3 methods]
Java, lazy, depth first. Avoid circular paths, throws FileSystemLoopException
Stream<Path> Files.walk(path). May throw error when missing access permission. NOFOLLOW_LINKS is default
Also goes through subdirectories
May encounter files it does not have permission to read
Stream<Path> Files.find(path, depth, BiPredicate). ...; // Catch Exception e; BiPredicate using Path, BasicFileAttributes
Stream<Path> Files.list(path) throws IOException // Note difference with File.list() // Only lists files in current directory
Views 
Faster for multiple attributes; Fewer trips; Adapts to file system
View creation [5]
BasicFileAttributes data = Files.readAttributes(path, BasicFileAttributes.class); // Cannot modify, watch for questions!
BasicFileAttributeView.class // Can also alter
DosFileAttributes; 
PosixFileAttributes
Attempts to modify do not compile
View access [4]
data.isOther(); 
data.lastAccessTime(); 
data.creationTime(); 
data.fileKey();
View modifying [4]
Make sure the 'view' versions are used consistently
BasicFileAttributeView view = Files.getFileAttributeView(path,BasicFileAttributeView.class);
BasicFileAttributes data = view.readAttributes();
view.setTime(lastModifiedTime,null, null);
Comparing IO with NIO.2 
Benefits of reading BasicFileAttributes [3]
Faster for multiple attributes
Fewer trips
Adapts to file system
Benefits of NIO.2 over IO [3]
Supports file system dependent attributes
Allows you to traverse a directory directly 
Supports symbolic links

Chapter Ten - JDBC
Key JDBC interfaces and Implementation
Driver - FooDriver
Connection - FooConnection // Created using static method in DriverManager
Statement - FooStatement
ResultSet - FooResultSet
Import java.sql.*;
try(Connection conn = DriverManager.getConnection(url); // Optional username/password
	Statement stmt = conn.createStatement();
	ResultSet rs  stmt.executeQuery(“Select name from animal:)) {
		while(rs.next())
			System.out.println(rs.getString(1));
}
Connection [3]
conn.setAutoCommit(boolean)
conn.commit(); // Commits all previous 
conn.rollback(); // Cancels all previous statements
JDBC URL format [2]
Protocal:Product/DatabaseName (Vendor:ConnectionDetails) (could be mostly anything)
jdbc:mysql://localhost:3306/zoo // Note location shouldn't just be a number and may contain additional colons
Older method [4]
Throws ClassNotFoundException
Class.forName(“org.postgresql.Driver”);	// Still works. Watch out for questions where version number is mentioned
Was required for Java 3 and below
If Java >=4 then META-INF/service/java.sql.Driver is required // Otherwise SQLException is thrown
ResultSet Type [3]
ResultSet.TYPE_FORWARD_ONLY	// Can’t go backward, watch for question that scroll with this of default!!!
ResultSet.TYPE_SCROLL_INSENSITIVE // Can go backward. 
ResultSet.TYPE_SCROLL_SENSITIVE // Also sees latest (updated) data, not well supported
ResultSet Concurrency Mode (second argument only, but does compile, but means something else) [2]
ResultSet.CONCUR_READ_ONLY
ResultSet.CONCUR_UPDATABLE // Less used - Least used
Statement  [5 - 4 methods]
e.g. Statement stmt = conn.createStatement(ResultSet.YPE_SCROLL_INSENSITIVE, ResultSet.CONCU_READ_ONLY);
bool b = stmt.execute() // Can alter; Cannot return data; Boolean; true for select; false for alteration
ResultSet rs = stmt.executeQuery() // Cannot alter: Can return ResultSet (Running another query closes first rs!)
stmt.executeUpdate() // Can alter; Return nr (int) rows changed
execute can run a select query and can run an update query
Reading ResultSet [5, 9 methods]
while(rs.next()) { int id = rs.getInt(“id”); }
.getBoolean(); .getInt(...); .getDouble(); .getLong(); // Int not spelled in full
.getString(...); .getObject();
.getData(); .getTime(); .getTimeStamp(); // java.sql.Date/Time/TimeStamp
Argument is column label or number; Numbers start at 1 not 0;
SQL Date Conversion [2]
java.sql.Date sqlDate = rs.getDate(1);
LocalDate localDate = sqlDate.toLocalDate(); // This is a method not a factory
JDBC Date and Time [3]
java.sql.Date - java.time.LocalDate - Date only
java.sql.Time - java.time.LocalTime - Time only
java.sql.TimeStamp - java.time.LocalDateTime - Date and Time
Scrolling ResultSet [8 methods]
void afterLast(); void beforeFirst(); // Surprisingly these return void. 
boolean first(); boolean last(); boolean next(); boolean previous() // Spelling in full!
boolean absolute(int rowNum); boolean relative(int rowNum); // Negative numbers start from end. absolute(0) = false; Extreme relative numbers place in beforeFirst or afterLast position.
Closing Database Resources [5]
Try (Connection conn = DriverManager.getConnection(url);	….);
The ‘old’ way uses a finally block and lots of checks to see what still is open. 
Exceptions
catch(SQLException e) { e.getMessage(); e.getSQLState(); e.getErrorCode(); }
Also note that ResultSet has a close method that automatically gets called when a  new rs is assigned of the Statement closes.

Watch out for
Watch of functional interfaces that don't specify a Generic as these are assumed Object, which limits the available methods.
Watch for Exceptions that are being caught that can't be thrown
Auto boxing does not happen in relation to lambda's
Watch for comparator doing reverse ordering, in which case the binary search would also need the comparator, otherwise it will fail
Keep watching for unhandled/declared Exceptions!
Still to do
System.out. could be used as Output steam, look up what this was about
Review serialization
Which Files methods throw exceptions??





