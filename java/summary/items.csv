ItemNr,Question,Answer
1,Instanceof [4],myObject instanceof ClassNEWLINEComparing unrelated classes does not compileNEWLINECompare to null returns falseNEWLINEInstance can be compared to all interfaces as a subclass could implement
2,Equals [2 notes],Reflexive (a to a > true); Symmetric(a to b = b to a); Transitive (if a to b & b to c then a to c); Consistent (a to b = a to b) NEWLINEComparison to null >> false
3,Equals steps [4],Input Object obj; NEWLINECheck instance of; (Can also be used to compare arrays)NEWLINECast and compareNEWLINEReturn primitive boolean
4,hashCode [3 notes],obj.hashCode();NEWLINEUse ‘fixed’ variables. E.g. don't use weight which could changeNEWLINEWhen equals is true hashcode should be same
5,Enum methods [4],s.name () // Returns valueNEWLINEs.ordinal () // Returns position as intNEWLINESeason.valueOf("Summer"); // Returns Enum constantNEWLINESeason.values() // Returns array of values
6,Enum basics [3],enum Season { WINTER SUMMER }; Upper case is conventionNEWLINESemicolon compulsory when more than values and field values are listed NEWLINETry to keep enums simple
7,Enum usage [7],Do not extend but can implement an InterfaceNEWLINEDo not compare to int; NEWLINECan use in switch but use SUMMER not Season.SUMMER!NEWLINECan be privateNEWLINECan not be members but not localNEWLINECan be printed directly // Prints SUMMER not Season.SUMMERNEWLINEBoolean.False // Works is a thing..
8,Enum advanced [2],Can add state SUMMER (“warm”) also add field and private or default (!) constructor (not protected or public) field may be public!NEWLINEOr assign method to each value and use overall abstract or default method. eg WINTER { public void doSometh() { ..} } SUM...
9,Member inner classes [6],Can be public private protected or defaultNEWLINECan be abstract or finalNEWLINECannot declare static membersNEWLINECompiling creates two .class files e.g. Outer.class & Outer$Inner.classNEWLINEHave access to all members of enclosing class using Outer.this.member or Level1.Level2.this.m or Level2.this.mNEWLINEInstantiated using new Outer.new Inner(); or outer.new Inner(); // Can't be instantiated directly from static (!) main method!
10,Local inner classes - Declared in method [4],Same as member inner except: NEWLINENo access specifier (as already local to the method). Cannot be staticNEWLINEOnly have access to local variables if effectively finalNEWLINECan be instantiated within method using new Inner without object of outer class
11,Anonymous inner class [5 - 3 notes],Does not get name just bodyNEWLINEExtends existing class or implements interface NEWLINEEnds in semicolon! Watch out for this! NEWLINEabstract class MyAbs{ abstract void doSometh(); } // The abstract class without method implementationNEWLINEMyAbs anno = new MyAbs() { void doSometh() { [implementation] } }; // Create anonymous class with implementation
12,Static nested classes [6],Can be instantiated without objects of enclosing classNEWLINECannot access members of enclosing class without explicit objectNEWLINECan be private etcNEWLINEStatic nested classes can be imported using either import static or normal importNEWLINEimport static bird.Toucan.Beak;NEWLINECan be extended by concrete (non-static) member/inner classes.
13,Ch01 - Other [9],Abstract classes can extend concrete classesNEWLINEIf you overwrite the public String toString method that will get called when printing objectNEWLINEVirtual method invocation - Implementation depends on classNEWLINEAnnotation - @Override - indicates a method is being overwritten NEWLINERemember all inteface methods are publicNEWLINEStatic initializer run even when the class is not initializedNEWLINESystem.out.println(); // Without argument print blank lineNEWLINEInvariant property of an object - A property that remains true regardless of how the object is modified.NEWLINEVariable accessed from static location must be static; not assigned at declaration >> can't be final
14,Functional interface - @FunctionalInterface [2 notes],Contains exactly one abstract method which it may contain through inheritanceNEWLINEMay contain other static/default methods
15,Lambda Rules [6],If more than one variable parentheses are requiredNEWLINEIf input variables are declared all must be declared and parentheses are requiredNEWLINEWhen return keyword is used {} are requiredNEWLINEWhen {} are used ; is requiredNEWLINEVariables must be initialized if used (don't get default values)NEWLINEHas access to final members and cannot reuse the same identifiers
16,Lambda Syntax Examples [5],a OR (Animal a) OR () OR (Animal a Duck d) OR (ab) OR ()NEWLINENOT: (int x y) // Both must be declaredNEWLINEa.canHop() OR { return a.canHop(); } OR new Duck() OR {} OR {return;} OR { int x = 0; return 5; }NEWLINENOT: (int x) -> { int x = 0; return 5; } // Can’t redeclare (i.e. x)NEWLINENOT: () -> {int x; return x >0; } // Variables must be initialized if used!
17,Polymorphism [5],The reference determines which properties are availableNEWLINEThe object determines the behaviorNEWLINEMethods always call the instance variables available in the object // !!!NEWLINEStatic methods behave depending on referenceNEWLINEVariables behave like static methods
18,Design Principles - Established idea/best practice. General solution to common problems [7 - 4 notes],Encapsulating: private fields with public getters and settersNEWLINEJavaBeans; Properties are private; get set is (optional for Boolean)NEWLINEis-a; has-aNEWLINEComposing objectNEWLINECreate object from smaller pieces such as arms and legsNEWLINEThese pieces can be instantiated in the constructorNEWLINEThis way the pieces can be reused elsewhere
19,Design pattern: Singleton [5 3 important pieces],Private constructor - private SingletonName() {}NEWLINEPrivate static final member/instance - private static final SingletonName instance = new SingletonName();NEWLINEAccessed using public static method - public static SingletonName getInstance() { return instance; }NEWLINESingle shareable instance; Used by multiple instances; Faster data loadingNEWLINEBecause the constructor is private the singleton class becomes effectively final because a subclass constructor won't be able to call super();
20,Design pattern: Singleton with Lazy instantiation [3 points],Check is instance==null in get InstanceNEWLINEinstance is not finalNEWLINEIs not thread safe unless marked as synchronized
21,Design pattern: Creating Immutable objects [5],Use constructors to set all propertiesNEWLINENo settersNEWLINEMark instance variables private and finalNEWLINEDon't allow access to mutable objects (return copies instead or use Collections.unmodifiableList())NEWLINEPrevent overwriting of methods ((mark class OR methods final) OR mark the constructor private and use a factory pattern)
22,Design pattern: Builder pattern [3],Separate class to set and build instanceNEWLINETightly coupledNEWLINESometimes static inner class can call private constructor
23,Design pattern: Factory pattern [1],Calls relevant class based on e.g. the animal name in switch statement
24,Generic Methods [4 notes],Useful for static methods where the generic isn't determined by the classNEWLINEpublic static <T> void methodName(T t) ()NEWLINEpublic static <T> T methodName(T t) ( return t; ) // Extra T required as method returns somethingNEWLINECan be called using: ClassName.<String>methodName(s); // Complicated but valid <> not required
25,Bounds - Allows methods to accept lists of limited types [4],List<?> list = ..NEWLINEUpper bound: <? extends Number>; Number of anything that extends NumberNEWLINELower bound: <? super String>; String or super classes of // This is the only one you can add element to directly!NEWLINEUse as reference only; Can only add elements directly to ? super ...
26,Collections [6],List: ordered collection; May contain duplicates; Access by indexNEWLINESet: No duplicate entriesNEWLINEQueue: Has order; Typically first in-first out other orderings possibleNEWLINEMap: Keys to values no duplicate keysNEWLINECan’t be null: When sorting is involved (everything that is labelled 'tree'); ArrayDeque; HashtableNEWLINECan be printed directly using System.out.println();
27,Common collection methods [6],boolean add(E element); NEWLINEboolean contains(Object object); NEWLINEboolean remove(Object object);NEWLINEint size(); NEWLINEvoid clear(); NEWLINEboolean isEmpty(); 
28,List: Adding getting setting removing [5],void add(E element); List<Object> l.add(123); // Works because Integer is also a number and also an ObjectNEWLINEvoid add(int index E element); NEWLINEE get(int index); NEWLINEE set(int index E e)	// Replaces and return originalNEWLINEvoid remove(int index); // Different from common method this takes primitive!
29,List: Index [2],int indexOf(Object o); // Find first; -1 if not foundNEWLINEint lastIndex(Object o); // Find last; -1 if not found
30,Old List Looping Method [1 3],Iterator iter = list.iterator(); while(iter.hasNext()) { String string = (String) iter.next(); } // hasNext >> next
31,Set - No duplicates [2],HashSet - Uses HashCode to quickly retrieve - No sortingNEWLINETreeSet - Has order - Sorts - Needs to implement Comparable
32,TreeSet - Implement NavigableSet interface [4 methods],E lower(E e) // < e; E floor(E e) // <= e; E ceiling(E e) // >= e; E higher(E e) // > e // or returns nullNEWLINElower < floor <= e <= ceiling < higherNEWLINENEWLINEQueue [3 types 8 methods]
33,Queue [3 types 8 methods],ArrayDeque; LinkedList; Stack;NEWLINEFIFO (most common); ArrayDeque: offer > peek > pollNEWLINELIFO; Stack: push > peek > pop
34,Queue: Adding [3],boolean add(E e); // Adds element to the back returns true or throws exceptionNEWLINEboolean offer(E e); // Adds element to the back returns true/false [ArrayDeque]NEWLINEvoid push(E e); // Adds element to start makes it a double ended queue
35,Queue: Peeking [2],E peek(); Returns next element or null if empty [ArrayDeque Stack]NEWLINEE element(); // Returns next element throws exception if queue is empty
36,Queue: Removing [3],E poll(); Removes and returns next element or null if empty [ArrayDeque]NEWLINEE remove(): Remove and returns next element or throws exceptionNEWLINEE pop(); // Removes and returns next element throws exception if empty
37,Stack methods [3],void push(E e); // Adds element to the front of the queue. This makes it a double ended queue [ArrayDeque Strack]NEWLINEE pop(); // Removes and returns next element throws exception if emptyNEWLINEE peek(); Returns next element or null if empty [ArrayDeque Stack]
38,Map - Has value and key [3 2 types 10 methods],TreeMap – In order of keys; NEWLINEHashtable – No predictable order; HashMapNEWLINEDoesn’t extend Collection
39,Map: Putting getting and removing [4 - 3],V put(K key V value) // Adds or replaces key/value pair. Returns previous value or null. Adding the same key overwrites does not throw an Exception!NEWLINEV get(Object key) // Returns values based on keyNEWLINEV remove(Object key) // Returns null if not found'NEWLINEThere is not Add method!
40,Map: Common methods [3],int size(); NEWLINEboolean isEmpty(); NEWLINEvoid clear() // Removes all keys and values
41,Map: Contains [2],boolean containsKey(Object key); NEWLINEboolean containsValue(Object); // There is no .contains() method
42,Map: Keys and values [2],Set<K> keySet() // Returns keys e.g. map.keySet();NEWLINECollection<V> values() // Returns values e.g. map.values();
43,Sorting [1],Sorting Order: [0-9][A-Z][a-z]
44,Comparable [7] ,class MyClass implements Comparable<MyClass> // Comparable using genericsNEWLINEInterface - implement compareTo method NEWLINEid – a.id sorts ascending. e.g. this - thatNEWLINEReturn: Zero when equal; < 0 - this object is smaller; > 0 - this object is greaterNEWLINEStrongly recommended that compareTo() and equals() are consistentNEWLINELegacy code uses object as input and thus requires casting before comparisonNEWLINEComparable is a functional interface no sense to implement using lamba as the purpose is the implement inside the object being compared
45,Comparator [5],Separate class<> that allows for sorting by different variables NEWLINECould implemented as inner classNEWLINEMethod: compareNEWLINEMethod can be implemented using lambaNEWLINECan be used to implement multiple fields
46,Searching and Sorting [2],Collections.sort(myElements) expects elements to implement Comparable otherwise fails to compileNEWLINECollections.sort(myElements myComparator) Alternative using Comparator
47,Method References using :: [3],System.out::println // Will infer argument - No ()!NEWLINEComparator<Duck> byWeight = DuckHelper::compareByWeight; // Replaces the below…NEWLINEComparator<Duck> byWeight = (d1 d2) -> DuckHelperbhai.compareByWeight(d1 d2);
48,Collection methods/iterators? [9 6 methods],list.removeIf(s -> s.startsWith("A"));NEWLINElist.replaceAll(x -> x*2);NEWLINElist.forEach(System.out::println); // Only takes Consumer<> no variations!NEWLINEmap.computeIfPresent NEWLINEmap.computeIfAbsentNEWLINEmap.merge(someKey someAltValue BiFunction); [3]NEWLINEKey already in map: Result of functionNEWLINEKey not in map: Value addedNEWLINEFunction returns null for existing value: Remove
49,map.merge(someKey someAltValue BiFunction); [3],Key already in map: Result of functionNEWLINEKey not in map: Value addedNEWLINEFunction returns null for existing value: Remove
50,Standard Interfaces [8],Functional InterfaceNEWLINE# ParametersNEWLINEReturn TypeNEWLINEMethodNEWLINESupplier<T>NEWLINE0NEWLINETNEWLINEget
51,Standard Interface Notes [5],Arguments listed as: Input Input OutputNEWLINEIf generic is missing Object is assumedNEWLINEPredicate<Integer> p1 = i -> i > 0 p2 = p1.negate(); // Multiple can be assigned on one lineNEWLINEConsumer<String> prt = System.out::println; // Assign method reference to interface NEWLINEPredicate<Integer> belowZero = i -> i < 0; Predicate<Integer> above = belowZero.negate(); // Negate existing predicate
52,Optional - Creating [3],Optional.empty();NEWLINEOptional.of(...); // Create optionals cannot use nullNEWLINEOptional.ofNullable(...); // Can handle null
53,Optional - Reading [7 8 methods],opt.get(); // Throws NoSuchElementException (RunTime)NEWLINEboolean opt.isPresent(); NEWLINEopt.ifPresent(Consumer c); NEWLINEopt.orElse(T other); // Returns other value if none presentNEWLINEopt.orElseGet(Supplier S); // Supplier onlyNEWLINEopt.orElseThrow(Supplier S) // Throws specified exception if no value e.g. opt.orElseThrow(() -> new RuntimeException()));NEWLINEAlso has methods: filter(P) map(F/U)
54,Create Streams [6 ways],Stream<String> empty = Stream.empty(); NEWLINEStream.of(1 2 3); // From dataNEWLINEStream<String> fromList = list.stream();  // Don't do this on MapNEWLINElist.parallelStream(); // From list (sorting does not affect original list)NEWLINEStream<Double> randoms = Stream.generate(Math::random); NEWLINEStream<Integer> oddNumbers = Stream.iterate(1 n -> n + 2); 
55,Intermediate Operations [8 - 9 methods],.filter(Predicate)NEWLINE.distinct()  // Removes duplicates using equalsNEWLINE.limit(int)  NEWLINE.skip(int)NEWLINE.map()  // Uses Function or UnaryOperatorNEWLINE.flatMap() // Always produces a non-parallel stream requires lamba (to convert to stream)NEWLINE.sorted(); .sorted(Comparator); // Note Comparator.reverseOrder() not Comparator::reverseOrderNEWLINE.peek() // Doesn't change stream
56,Terminal Operations [10 3-2-3-1-1-3 = 13],long count(); Optional<T> min(); Optional<T> max(); // Reductions; Returns Optionals! min max need Comparator argNEWLINEThese is no sum(); // Only exists for primitive streamsNEWLINEfindAny(); findFirst(); // Returns Optional<T> these are not reductions they don't take arguments. Returns Optionals!NEWLINEallMatch(); anyMatch(); noneMatch(); // boolean or runs foreverNEWLINEforEach(); forEachOrdered(); // Second is for use with parallel streamsNEWLINECollect: Stream.of("h""i""g""h").collect(StringBuilder::new StringBuilder::append StringBuilder::append);NEWLINEReduce: Stream.of("h""i").reduce("" (s c) -> s + c); // Used BinaryOperator or BiFunction [3]NEWLINE2 arg > Object; start value + accumulatorNEWLINE3 arg > Object; start value + accumulator + combiner > Most useful for parallel streamNEWLINE1 arg > Optional as may be empty! Collector
57,Reduce: Stream.of("h""i").reduce("" (s c) -> s + c); // Used BinaryOperator or BiFunction [3],2 arg > Object; start value + accumulatorNEWLINE3 arg > Object; start value + accumulator + combiner > Most useful for parallel streamNEWLINE1 arg > Optional as may be empty! Collector
58,Printing a stream [3],s.forEach(System.out::println); // Print using forEachNEWLINEs.peek(System.out::println).count(); // Print using peek remember to add a terminal operationNEWLINESystem.out.println(s.collect(Collectors.toList())); // Convert to list and print
59,Primitive Streams [3 types 4 methods],IntStream; LongStream; DoubleStream; // Watch spellingNEWLINEIntStream.range(16); IntStream.rangeClosed(15);NEWLINEDoubleStream.generate(Math::random); DoubleStream.iterate(0.5 d -> d / 2);
60,Functions to convert different stream type [3],To same always map i.e. can't call others on self!NEWLINESteam = mapToObj; DoubleStream = mapToDouble; IntStream = mapToInt; LongStream = mapToLongNEWLINEWatch out for mapToBool nonsense!
61,Interface to use as parameter in those map... functions [2],StartToEnd e.g. IntToLongFunction ToLongFunctionNEWLINESelfUnaryOperator e.g. DoubleUnaryOperator (stream to stream is just Function)
62,Functional interfaces for double int long [5 3x6],Double/Int/Long  Supplier/Consumer/Predicate/Function<R>/UnaryOperator/BinaryOperator NEWLINEReturn generic is specified for Function and only for Function!NEWLINEmethods often renamed to reflect type (not for Consumer Predicate Function)NEWLINEThere's no BiConsumer BiPredicate BiFunction (only BinaryOperator)NEWLINEBooleanSupplier also exists
63,Conversion Interfaces To and Between Primitive Streams [3x23;3x33;4x1],ToDouble/ToInt/ToLong Function<T>/BiFunction<TU> // applyAs Double/IntLongNEWLINEDouble/Int/Long To Double/Int/Long Function // applyAs Double/IntLongNEWLINEObj Double/Int/LongConsumer<T> // Accept note generic parameter // Takes Object and primitive
64,Optional with primitive streams [2],OptionalDouble; OptionalInt; OptionalLongNEWLINEe.g. stream.average(); // Returns OptionalDouble
65,Primitive optional methods [2 4],Getting as primitive: getAsDouble(); getAsInt(); getAsLong();NEWLINE.orElseGet(Double/Int/LongSupplier);
66,Primitive stream stats [3],.max(); returns OptionalDouble/Int/Long;NEWLINE.sum(); returns double/int/long;NEWLINE.average(); // Always return OptionalDouble not written in full >> Actually it is written in full! (Double check in book)
67,Summary Statistics [5],IntSummaryStatistics stats = ints.summaryStatistics(); // Written in full!NEWLINEstats.getMax(); NEWLINEstats.getMin();NEWLINEstats.getAverage(): // Apparently returns Double and not Optional<Double> (different from above)NEWLINEIntSummaryStatistics incomeStats = Employee.persons() .stream()
68,Advanced Stream Pipeline Concepts [1],If a stream is created based on a list and an element is added to the list that element will still be part of the stream.
69,Date and Time - Basics[4],import java.time.*;NEWLINERemember Date and Time are created using factory static methodsNEWLINEDaylight Savings Time - Java is smart enough to adjust for thisNEWLINE2016-08-28T05:00-07:00: Do 5 + 7 to get GMT time 12
70,DateTime - Classes [1 - 4 types],LocalDate; LocalTime; LocalDateTime; ZonedDateTime 
71,DateTime - Create [7 - 6],LocalTime.now() NEWLINELocalDate.of(2015 Month.JANUARY 31)NEWLINEZonedDateTime.of(201512061530200zone); // No option to pass in Enum for month in this oneNEWLINEZonedDateTime.of(localDate localTime zone); // BetterNEWLINEZoneId zone = ZoneId.of(“US/Eastern”);NEWLINEZoneId.systemDefault();NEWLINERunTime Exception: DateTimeException could be thrown if invalid numbers are passed in
72,To Epoch [3],long LocalDate.toEpochDay()NEWLINElong Local/ZonedDateTime.toEpochSecond()NEWLINENeither exist for Time only classes
73,Instants [4 3 methods],Specific moment in time based on GMTNEWLINEInstant.now()NEWLINEzonedDateTime.toInstant(); // Not just DateTime has to have zone info tooNEWLINEInstant.ofEpochSecond(long);
74,Manipulating Dates and Times [4 - 2x8+2 2 notes],.plus/minusYears Months Weeks Days Hours Minutes Seconds NanosNEWLINE.plus/minus(period); NEWLINECan be strung together; Can only be applied to the logical classesNEWLINEPeriods [4 - 5 methods 3 notes]
75,Periods [4 - 5 methods 3 notes],Period.ofYears(); .ofMonths(); ofWeeks(); ofDays(); of(year month day);NEWLINEDon't string together only last one will applyNEWLINENot for timeNEWLINEP1Y2M3D or P21D // when printing
76,Duration [5 7 methods 2 notes],Duration.ofDays(); .ofHours(); .ofMinutes(); .ofSeconds(); .ofMillis(); .ofNanos(); NEWLINEDuration.of(1 ChonosUnit.Days); Units: HOURS MINUTES SECONDS MILLIS .NANOS; NEWLINEOnly one unit at a time don't string together only last one will apply. There's also ChronoUnit.HALF_DAYSNEWLINEFor time (and days)NEWLINEPT1H PT10S // Example of when printing; PT60S == PT1M
77,Comparing [3],bool this.isBefore(other); this.isAfter(other); // Date and timeNEWLINEpublic long until(Temporal endExclusive  TemporalUnit unit) //  e.g. date1.until(date2 ChronoUnit.DAYS)); // Days between 1 & 2NEWLINEChronosUnit.MINUTES.between(timeOne timetwo); 
78,Get date elements [5],.getDayOfWeek(); MONDAY // Returns EnumNEWLINE.getMonth(); JANUARY // Returns EnumNEWLINE.getYear(); 2020  NEWLINE.getDayOfYear(); 120NEWLINE.getDayOfMonth(); 20
79,DateTimeFormatter [2],import java.time.format.*;NEWLINEOnly  call on appropriate data types but Time can be called on dateTime.
80,Date format directly [3],date.format(DateTimeFormattter.ISO_LOCAL_DATE); 2020-01-20NEWLINEtime.format(DateTimeFormattter.ISO_LOCAL_TIME); 11:12:34NEWLINEdateTime.format(DateTimeFormattter.ISO_LOCAL_DATE_TIME); 2020-01-20T11:12:34
81,Create DateTime formatter [2],DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT); // Only DateNEWLINEDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT); // Only prints time
82,DateTime can be either object of parameter [2],shortDateTime.format(dateTime); // 1/20/20 (Date piece only)NEWLINEdateTime.format(shortDateTime); // Equivalent!
83,DateTime Format styles [3],FormatStyle.ISO_LOCAL_DATE/_TIME_DATE_TIME // 2020-01-20T11:12:34NEWLINEFormatStyle.SHORT // 1/20/20 11:12 AMNEWLINEFormatStyle.MEDIUM // Jan 20 2020 11:12:34 AM
84,Date time pattern [8],FormatStyle.ofPattern(“MMMM dd yyy hh:mm”); // Can throw runtime exception with non usable patternNEWLINEyyyy - year: yy = 16 yyyy = 2016NEWLINEMMMM - Month: M = 1 MM = 01 MMM = Jan MMMM = January // Month is the only one using capitalsNEWLINEdd - date: d = 1 dd = 01NEWLINEhh - hour: h = 1 hh = 01NEWLINEmm - minute: m mmNEWLINE =    : = :NEWLINE.parse(“01 02 2015” f); // First String then formatter
85,Formatting Numbers [7 5 methods 2 notes],java.text.*;NEWLINEen = NumberFormat.getInstance(Locale.US); // Or no argumentNEWLINEen = NumberFormat.getNumberInstance(...);NEWLINEen = NumberFormat.getCurrencyInstance(...);NEWLINEen = NumberFormat.getPercentInstance(...);NEWLINEen = NumberFormat.getIntegerInstance(...);NEWLINEen.format(someValue);
86,Common String methods [11],String state method [3 - 7 methods]NEWLINE.isEmpty(); .length()NEWLINE.charAt(4); .indexOf('e'); .indexOf("de")NEWLINE.startsWith("a"); .contains("ll")NEWLINEString alteration methods [4]NEWLINE.trim()NEWLINE.substring(24)NEWLINE.toUpperCase(); .toLowerCase();NEWLINE.replace('a''1')NEWLINEInternationalization and Localization [3]NEWLINEInternationalization: The process of designing a program such that it can be adapted.
87,String state method [3 - 7 methods],.isEmpty(); .length()NEWLINE.charAt(4); .indexOf('e'); .indexOf("de")NEWLINE.startsWith("a"); .contains("ll")
88,String alteration methods [4],.trim()NEWLINE.substring(24)NEWLINE.toUpperCase(); .toLowerCase();NEWLINE.replace('a''1')
89,Internationalization and Localization [3],Internationalization: The process of designing a program such that it can be adapted.NEWLINELocalization: Actually supporting multiple locales.NEWLINELocale: A specific geographical political or cultural region
90,Creating Locale [8 - 6 methods],Locale locale = Locale.getDefault();  // en_USNEWLINEnew Locale(“fr”); new Locale(“hi” “IN”); // Capitalization mattersNEWLINELocale l1 = new Locale.Builder()NEWLINE    .setLanguage(“en”) // Capitalization does not matterNEWLINE    .setRegion(“US”)NEWLINE    .build();  // Uses builder design patternNEWLINELocale.setDefault(new Locale(“fr”)); // Overwrites defaultNEWLINELocale.GERMANY 
91,Properties File [4],Zoo_en_US.propertiesNEWLINEhello=Bonjour OR animal:dolphin OR animal dolphin NEWLINE// # or ! are used for comments in resource filesNEWLINECan end line with \ if that helps clarity
92,Load Properties into ResourceBundle [3],ResourceBundle rb = ResourceBundle.getBundle(“Zoo” new Locale(“en”)); // Locale optionalNEWLINErb.getString("key"); // No default value allowed; null if key not foundNEWLINErb.keySet(); 
93,Properties Functionality [4],Properties props = new Properties();NEWLINErb.keySet().stream().forEach(k -> props.put(k rb.getString(k)));NEWLINE.getProperty("key" [optional] "default"); // Default value is returned if property is not foundNEWLINE.get(); // No default value allowed
94,Java Class Resource Bundle [5],Actual java file e.g Zoo_en_US.javaNEWLINEextends ListResourceBundle NEWLINEprotected Object[][] getContent { return new Object[][] { {"key""value"} }; } NEWLINErb.getObject("key");NEWLINECan use other types than String
95,Bundle order [7],.java before .properties NEWLINEFirst drop countryNEWLINEThen drop languageNEWLINEThen default localNEWLINEDefault local based on language onlyNEWLINEThen default bundleNEWLINEFinally MissingResourceException (RunTime)
96,Parent bundles [2],If not found java can look in parents. Remove elements till you get to the topNEWLINEe.g. Zoo_fr_Fr.java >> Zoo_fr.java >> Zoo.java // Note: does not switch to .properties or Zoo_en even if that's the default Locale
97,Notes [3],If catch and finally both throw an exception the one from the finally get throughNEWLINERethrowing Exception: When you write Exception e in the catch statement java assumes catch the exception that the method throwsNEWLINEYou can't catch an exception that's not throwable (as declared in the method signature) but you can say you could throw something (in the method signature) without actually being able to do it. Keep watching for these!
98,Create exceptions [2],Extend Exception or RuntimeExceptionNEWLINEConstructors (No argument Exception e String message)
99,Multi catch [3],Use | but only one eNEWLINEMeant to catch unrelated exceptions NEWLINEDo not reassign a new exception to e as compiler doesn't know which one it's going to be
100,Try with resources [5],Resources are closest in reverse order after the try statements ends after which catch and finally are run!NEWLINEImplement AutoCloseable or Closeable overwrite close() methodNEWLINEClosable only allow to throw IOExceptionNEWLINERecommended that close throws specific or no exceptions;If close is able to throw an exception a catch statement is required NEWLINEe.g. try (MyClass c = new MyClass()) { c.doSometh(); } 
101,Suppressed Exception [2],Multiple exceptions only the first is 'active' the rest are suppressedNEWLINEfor (Throwable t : e.getSuppressed()) { t.getMessage(); }
102,Assertion [6],assert i > 0; assert(I>0); assert i > 0: "OhNo!" // Look for colon! Any value or SupplierNEWLINEThrows java.lang.AssertionError if not trueNEWLINEBy default assertions are ignored by java; Needs to run with assertions enabled using java -enableassertions or java -eaNEWLINEjava -ea:sample.package... // Limit to package and subpackagesNEWLINEjava -ea:sample.package.MyClass -da // Limit to class (does not matter that -da comes after eaNEWLINEKeep an eye for question with assert without assertions enable those will run!
103,Concurrent Interfaces [2],Runnable - void run(); // For action; No return no exceptionsNEWLINECallable<T> T run(); // For tasks; Returns generic and throw Exceptions
104,Create thread [10],implements Runnable (preferred)NEWLINE    Overwrite void run()	NEWLINE    In main  (new Thread(new MyClass))).start();NEWLINE    Pros: Allow you to extend other classes; Better OO designNEWLINEextends ThreadNEWLINE    Overwrite void run()NEWLINE    In main (new MyClass()).start();NEWLINE    Pro: potential to set priorityNEWLINEExecutorServiceNEWLINEBeware of cases where run is called instead of start as those run on the same thread
105,Polling with Sleep [2],Check whether thread has finished include Thread.sleep(...); To prevent constant checking.NEWLINEDeal with InterruptedException 
106,ExecutorService [7 5 types],Import java.util.concurrent.*;NEWLINEObtain through Executors Factory classNEWLINE                 ExecutorService service = Executors.newSingleThreadExecutor();NEWLINEScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();NEWLINE                 ExecutorService service = Executors.newCachedThreadPool();NEWLINE                 ExecutorService service =  Executors.newFixedThreadPool(int nThreads);NEWLINEScheduledExecutorService service = Executors.newScheduledThreadPool(int nThreads);
107,Executor service method [6],service.execute(Lamba Expression);NEWLINEAdd try/finally { if(service!=null) service.shutdown();NEWLINEisShutdown() // true after .shutdown() calledNEWLINEservice.awaitTermination(long timeout TimeUnit unit);NEWLINEisTerminated() // true after remaining threads have finished runningNEWLINEshutdownNow() // Attempt to stop all running tasks. Returns List<Runnable> with non-finished tasks
108,Submitting tasks [5],void execute(Runnable command); // Runnable onlyNEWLINEFuture<?> submit(Runnable task);  f.get(); >> null (Runnable doesn't return anything)NEWLINE<T> Future<T> submit(Callable<T> tasks); // Runnable or CallableNEWLINE<T> List<Future<T>> invokeAll(Collection<? Extends Callable<T>> tasks) throws InterruptedExceptionNEWLINE<T> T invokeAny(Collection<? Extends Callable<T>> tasks) throws InterruptedException ExecutionExpection
109,Future methods [6 - 5 methods]],boolean isDone(); // Is the task completeNEWLINEboolean isCancelled()NEWLINEboolean cancel()NEWLINEV get(); // Return null for Runnable // has Exceptions that need to be caught!NEWLINEV get(long timeout TimUnit unit) // In addition has timeoutExceptionNEWLINEThe future itself contains a reference e.g. java.util.concurrent.FutureTask@12ec34e which can be printed.
110,Scheduling Tasks [5 - 4 methods],schedule(Callable<V> callable long delay TimeUnit unit);NEWLINEschedule(Runnable command long delay TimeUnit unit);NEWLINEscheduleAtFixedRate() // Runnable 4 agrsNEWLINEscheduleAtFixedDelay // Runnable 4 agrsNEWLINETime units; TimeUnit.NANOSECONDS .MICROSECONDS .MILLISECONDS .SECONDS .MINUTES .HOURS .DAYS
111,Atomic Classes [4. 7],AtomicBooleanNEWLINEAtomicInteger; AtomicIntegerArrayNEWLINEAtomicLong; AtomicLongArrayNEWLINEAtomicReference; AtomicReferenceArray
112,Atomic Methods [2 7],get(); set(); getAndSet()NEWLINEincrementAndGet(); getAndIncrement(); decrementAndGet(); getAndDecrement();
113,Synchronized [3],synchronized(object/this/etc) // Needs something to synchonize e.g. (this) or a methodNEWLINEprivate synchronized void methodName(); // MethodNEWLINECannot be applied to variables
114,Concurrent Collections [10],CopyOnWriteArrayList // Makes copy when written to can be altered in loopNEWLINECopyOnWriteArraySet // Makes copy when written to can be altered in loopNEWLINEConcurrentSkipListSet // SkipList => tree => sorted - TreeSetNEWLINEConcurrentLinkedQueueNEWLINEConcurrentLinkedDequeNEWLINELinkedBlockingDequeNEWLINELinkedBlockingQueueNEWLINEConcurrentHashMapNEWLINEConcurrentSkipListMap // SkipList => tree => sorted - TreeMapNEWLINEe.g. Collections.syncronizedList(new ArrayList<>(Arrays.asList(123)));
115,Blocking Queues [4 - 6],offer(E e long timeout TimeUnit unit); // Or without the timeout partNEWLINEpoll(E e long timeout TimeUnit unit) // Returns E e?NEWLINEofferFirst; offerLast; pollFirst; pollLast;NEWLINENeeds catch(InterruptedException e);
116,Obtaining Synchronized Collections [9 - 8 methods 1 note],synchronizedCollection(Collection<T> c)NEWLINEsynchronizedList(List<T> list)NEWLINEsynchronizedMap(Map<KV> m)NEWLINEsynchronizedNavigableMap(NavigableMap<KV> m)NEWLINEsynchronizedNavigableSet(NavigableSet<T> s)NEWLINEsynchornizedSet(Set<T> s)NEWLINEsynchronizedSortedMap(SortedMap<MKV> m)NEWLINEsyncrhonizedSortedSet(SortedSet<T> s)NEWLINEDon't modify while iterating over these this will lead to ConcurrentModificationException
117,Parallel Streams [12 2 to create 3 terminal operations],stream.parallel(); NEWLINElist.parallelStream();NEWLINEAvoid stateful lambda expressions: Where results depends on state that might change during executionNEWLINE.forEachOrdered();NEWLINE.findFirst() .limit() .skip() // Are performed in an ordered fashion and are slowerNEWLINE.unordered() // Tells java order doesn't matterNEWLINEparallel reduce() requirements [4 - 3 args]NEWLINEIdentity > Accumulator > CombinerNEWLINEIdentity: must be defined such that .apply(identify u) is equal to uNEWLINEAccumulator must be associative and stateless such that (a op b) op c == a op (b op c)NEWLINECombiner: must be associative and stateless it aligns with the accumulatorNEWLINEparallel collect() requirements [3]
118,parallel reduce() requirements [4 - 3 args],Identity > Accumulator > CombinerNEWLINEIdentity: must be defined such that .apply(identify u) is equal to uNEWLINEAccumulator must be associative and stateless such that (a op b) op c == a op (b op c)NEWLINECombiner: must be associative and stateless it aligns with the accumulator
119,parallel collect() requirements [3],the stream is parallelNEWLINECollector.Characteristics.CONCURRENTNEWLINECollector.Characteristics.UNORDERED
120,CyclicBarrier [4 points],CyclicBarrier c = new CyclicBarrier(4); // number is threat count to be reached otherwise hangsNEWLINETakes second argument (lambda) to print somethingNEWLINEc.await(); // Waits for all tasks to finishNEWLINENeeds catch (InterruptedException | BrokenBarrierException e) {}
121,ForkJoin Framework - Recursion [6],java.util.concurrent.*;NEWLINEExtendNEWLINEOverride compute with if to trigger new task/actionNEWLINECreate ForkJoinTaskNEWLINECreate ForkJoinPoolNEWLINEStart
122,ForkJoin ExtendExtend [2],.. extends RecursiveAction - void compute(); // Returns void (like Runnable)NEWLINE.. extends RecursiveTask<T>  - T compute(); // Returns Generic (like Callable)
123,ForkJoin Override compute [8],include if statementNEWLINETrigger for new task/actionsNEWLINEAction invokeAll(new SomeAction() new SomeAction());NEWLINEForkJoin Task [4]NEWLINECreate new taskNEWLINEotherTask.fork();NEWLINEDo task on this threat  // Very important this is done beween fork and join other wise single it runs in a single threat manner. NEWLINEreturn thisTaskresult + otherTask.join();
124,ForkJoin Task [4],Create new taskNEWLINEotherTask.fork();NEWLINEDo task on this threat  // Very important this is done beween fork and join other wise single it runs in a single threat manner. NEWLINEreturn thisTaskresult + otherTask.join();
125,Create ForkJoinTask [2],ForkJoinTask<?> task = new SomeAction(); // Reference is called task despite being an actionNEWLINEForkJoinTask<T> task = new SomeTask(); // Enter generic
126,Create ForkJoinPool [1],ForkJoinPool pool = new ForkJoinPool();
127,Start the ForkJoinTask [4],pool.invoke(task); // No return value for actionNEWLINEDouble sum = pool.invoke(task); // Return type for taskNEWLINEIdentifying Threading Problems [4]NEWLINELiveness: The ability of an application to execute in a timely manner
128,Identifying Threading Problems [4],Liveness: The ability of an application to execute in a timely mannerNEWLINEDeadlock: Two threads are waiting for each other; Can't happen with SingleThreadExe...NEWLINELivelock: Occurs when threats are trying to resolve or avoid a deadlock they appear to be active but are conceptually deadlockedNEWLINEStarvation: A threat is unable to get access to the resource it needs
129,Managing race conditions [2],Two requests are being submitted at the same timeNEWLINEIdeally: access one and deny the other (rather than denying both)
130,Streams (the I/O kind) [4 notes],Byte stream: Use input stream and output streamNEWLINECharacter stream: Use reader and writer; Deals with encoding for you (though both can read character data)NEWLINEnew ObjectInputStream(new BufferedInputStream(new FileInputStream)))NEWLINEEnd of ObjectInputStream is detected by catching EOFException
131,InputStream - OutputStream > Abstract classes Do not instantiate! [3],FileInputStream - FileOutputStream > BytesNEWLINEBufferedInputStream - BufferedOutputStreamNEWLINEObjectInputStream - ObjectOutputStream > Higher level!
132,Reader - Writer > Also abstract! Do not instantiate! [3],FileReader - FileWriter > CharactersNEWLINEBufferedReader - BufferedWriterNEWLINEInputStreamReader - OutputStreamWriter > Character data from stream
133,Printers [2],PrintStream > Writes formatted java objects to binary streamNEWLINEPrintWriter > Writes java objects to text based output
134,Marking and reset and Skipping [4],.markSupported(); // Check support for marking; Watch for question on this will throw exception!NEWLINE.mark(int n); // Mark a location for the next n bytes; if not supported throws runtime exceptionNEWLINE.skip(numberOfBytesToSkip)NEWLINE.reset() // Go back to marked location Passing mark read limit may lead to exception when calling .reset()
135,Serializable [7],Tagging or marker interface (has no methods)NEWLINEClass and object within must be marked Serializable or transient (indicating it does not need to be saved)NEWLINEThrows NotSerializableException (Excepting)NEWLINEStatic variables are ignored (however values may have been retained if objects are serialized and immediately deserialized!)NEWLINEprivate static final long serialVersionUID = 1L; // Is stored; Watch for spelling; Recommended not requiredNEWLINEDeserialization may throw ClassNotFoundExceptionNEWLINENo class constructor or default initializations are used in the deserialization process
136,PrintStream - PrintWriter - Do not throw exceptions ? [5],Can open and write to files directly NEWLINEPrintWriter can work with OutputStream and format tooNEWLINESystem.out and System.err are actually PrintStream objectsNEWLINE.print(); println();NEWLINE.format(); = .printf();
137,Interacting with users - Old way [4],import java.io.*;NEWLINEBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));NEWLINESystem.in is also a system streamNEWLINEString userInput = reader.readLine();
138,Interacting with users - New way: [4],import java.io.Console;NEWLINEConsole console = System.console(); // Created using singleton patternNEWLINENote console could be null if not availableNEWLINEif (console != null) { String userInput = console.readLine(); }
139,Console write methods memorize these! [6],console.printf();  // Does not need the writer partNEWLINEconsole.format(); // Does not need the writer partNEWLINEconsole.writer().println; // Needs the writer partNEWLINEconsole.writer().print // Needs the writer partNEWLINEconsole.writer().write() // Needs the writer partNEWLINEconsole.flush(); // Write remaining output immediately; Recommended to call before read commands...
140,Console read methods [3],console.reader().read();NEWLINEconsole.readLine(); // Without reader()NEWLINEconsole.readPassword(); // Remember returns char[]; More secure avoids use of StringPool memory can be erased
141,java.io.File [6],Can reference both directory and filesNEWLINEAbsolute file path vs relativeNEWLINEUse '/' or "\\"NEWLINESeparatorNEWLINESystem.getProperty(“file.separator”));NEWLINEjava.io.File.separator
142,File elements [4 3],file.getName(); // Return last elementNEWLINEfile.getAbsolutePath(); // Adds rootNEWLINEfile.getParent() // Returns abstract pathname or null if parent directory is not namedNEWLINEThere is no .getRoot() method
143,File characteristics [5],file.exists(); // Non existing >> falseNEWLINEfile.isDirectory(); // Non-existing >> falseNEWLINEfile.isFile(); // Non-existing >> falseNEWLINEfile.length(); // Non-existing >> 0NEWLINEfile.lastModified // Returns number of milliseconds since the epoch non-existing >> 0
144,File alterations [4],file.renameTo(File); // There is no .copy() method NEWLINEfile.delete(); // returns boolean NEWLINEfile.mkdir(); NEWLINEfile.mkdirs()  // Makes directory; mkdirs - including missing parent directories
145,File listing [2],.listFiles()	// Returns File[] arrayNEWLINE.list(); // Returns String[] array >> Note that this is different from Files.list()!
146,Path [8],import java.nio.file.Path or .*NEWLINEPath interfaceNEWLINEDirect replacement for FileNEWLINEN Stands for Non-blockingNEWLINESupport for symbolic links (specific to NIO.2)NEWLINERefer to file or folder; NEWLINEAbsolute or relativeNEWLINEPaths: Factory class that can produce Path objects
147,Path symbols [2],. = current directoryNEWLINE.. = parent directory
148,Create Path [5],Paths.get(String); NEWLINEPaths.get(varag String[]); // Overloaded with varargNEWLINEPaths.get(URI); // URI (Uniform Resource Identifier) must reference absolute pathNEWLINEfile.toPath(); NEWLINEFileSystems.getDefault().getPath(...); // FileSystems factory class to create instances
149,Path methods  [2],These can be strung together where it makes sense (15 methods)NEWLINEImmutable: Ensure result is assigned!
150,Path to methods [3],path.toFile(); NEWLINEpath.toURI(); NEWLINEpath.toString();
151,Path elements [7],path.getNameCount(); // Returns the number of elements in the PathNEWLINEpath.getName(int index); // Returns a specific element of the Path as a new Path object; 0 does not refer to rootNEWLINEpath.subpath(0.3); // Excludes last nr obviouslyNEWLINEpath.getFileName(); // Returns PathNEWLINEpath.getRoot(); // Returns PathNEWLINEpath.getParent(); // Returns PathNEWLINEpath.toAbsolutePath(); // Create path starting from root
152,Path characteristics [1],path.isAbsolute(); // Does path start from root?
153,Path manipulate [4],path1.relativize(path2); // Show how to get to other file. Requires both to be either relative or abstract otherwise throws error!NEWLINEpath1.resolve(path2); // For joining paths; Running this with an absolute path as argument will return just the absolute path!NEWLINEpath.normalize(); // For cleaning up path symbols; Relative paths do not become absoluteNEWLINEpath.toRealPath(); // Checks that file exists after normalizing. Be sure to handle possible IOException e
154,Optional Arguments [5],NOFOLLOW_LINKS: // Don't traverse symbolic linksNEWLINEFOLLOW_LINKS  // Not the default!NEWLINECOPY_ATTRIBUTES // Also copy metadata. Default!NEWLINEREPLACE_EXISTING: Overwrite otherwise exception will be throw is file exists (not the default)NEWLINEATOMIC_MOVE: Perform the move in an atomic manner. If not supported a AtomicMoveNotSupportedException could be thrown.
155,Files check methods [2],Files.exists(path); // Does not throw an exceptionNEWLINEFiles.isSameFile(pp); // Throws IOException if either file does not exist or NoSuchFileException
156,Files alteration [6],Files.createDirectory(p); NEWLINEFiles.createDirectories(p);NEWLINEFiles.copy(pp); // Could take InputStream path options..) Can copy to outputstream which has to go second!NEWLINEFiles.move(pp);NEWLINEFiles.delete(p); // Throws IOException or RunTime DirectoryNotEmptyExceptionNEWLINEFiles.deleteIfExists(p);  
157,Files reading writing [4],Files.newBufferedReader(p); NEWLINEFiles.newBufferedWriter(p); // Use try with resources catch IOExp for reader/writer methodsNEWLINEFiles.readAllLines(p); // IOExcept list<String>  // Not a stream memory intensive // IOExceptNEWLINEFiles.lines(p); // IOExcept Stream<String> // Better than readAllLines(); Creates Stream<String> loads one bit at a time // IOExcept
158,File Attributes (specific to NIO.2) [9 methods],Files.isDirectory(); // Has to exist can refer to symbolic linkNEWLINEFiles.isRegularFile(); NEWLINEFiles.isSymbolicLink();NEWLINEFiles.isHidden(); // Catch IOException eNEWLINEFiles.size(); // Instead of .length(); !!NEWLINEFiles.getLastModifiedTime(); NEWLINEFiles.setLastModifiedTime();NEWLINEFiles.getOwner(); NEWLINEFiles.setOwner();
159,Walking and Searching using Files [6 3 methods],Java lazy depth first. Avoid circular paths throws FileSystemLoopExceptionNEWLINEStream<Path> Files.walk(path). May throw error when missing access permission. NOFOLLOW_LINKS is defaultNEWLINEAlso goes through subdirectoriesNEWLINEMay encounter files it does not have permission to readNEWLINEStream<Path> Files.find(path depth BiPredicate). ...; // Catch Exception e; BiPredicate using Path BasicFileAttributesNEWLINEStream<Path> Files.list(path) throws IOException // Note difference with File.list() // Only lists files in current directory
160,View creation [5],BasicFileAttributes data = Files.readAttributes(path BasicFileAttributes.class); // Cannot modify watch for questions!NEWLINEBasicFileAttributeView.class // Can also alterNEWLINEDosFileAttributes; NEWLINEPosixFileAttributesNEWLINEAttempts to modify do not compile
161,View access [4],data.isOther(); NEWLINEdata.lastAccessTime(); NEWLINEdata.creationTime(); NEWLINEdata.fileKey();
162,View modifying [4],Make sure the 'view' versions are used consistentlyNEWLINEBasicFileAttributeView view = Files.getFileAttributeView(pathBasicFileAttributeView.class);NEWLINEBasicFileAttributes data = view.readAttributes();NEWLINEview.setTime(lastModifiedTimenull null);
163,Benefits of reading BasicFileAttributes [3],Faster for multiple attributesNEWLINEFewer tripsNEWLINEAdapts to file system
164,Benefits of NIO.2 over IO [3],Supports file system dependent attributesNEWLINEAllows you to traverse a directory directly NEWLINESupports symbolic links
165,Connection [3],conn.setAutoCommit(boolean)NEWLINEconn.commit(); // Commits all previous NEWLINEconn.rollback(); // Cancels all previous statements
166,JDBC URL format [2],Protocal:Product/DatabaseName (Vendor:ConnectionDetails) (could be mostly anything)NEWLINEjdbc:mysql://localhost:3306/zoo // Note location shouldn't just be a number and may contain additional colons
167,Older method [4],Throws ClassNotFoundExceptionNEWLINEClass.forName(“org.postgresql.Driver”);	// Still works. Watch out for questions where version number is mentionedNEWLINEWas required for Java 3 and belowNEWLINEIf Java >=4 then META-INF/service/java.sql.Driver is required // Otherwise SQLException is thrown
168,ResultSet Type [3],ResultSet.TYPE_FORWARD_ONLY	// Can’t go backward watch for question that scroll with this of default!!!NEWLINEResultSet.TYPE_SCROLL_INSENSITIVE // Can go backward. NEWLINEResultSet.TYPE_SCROLL_SENSITIVE // Also sees latest (updated) data not well supported
169,ResultSet Concurrency Mode (second argument only but does compile but means something else) [2],ResultSet.CONCUR_READ_ONLYNEWLINEResultSet.CONCUR_UPDATABLE // Less used - Least used
170,Statement  [5 - 4 methods],e.g. Statement stmt = conn.createStatement(ResultSet.YPE_SCROLL_INSENSITIVE ResultSet.CONCU_READ_ONLY);NEWLINEbool b = stmt.execute() // Can alter; Cannot return data; Boolean; true for select; false for alterationNEWLINEResultSet rs = stmt.executeQuery() // Cannot alter: Can return ResultSet (Running another query closes first rs!)NEWLINEstmt.executeUpdate() // Can alter; Return nr (int) rows changedNEWLINEexecute can run a select query and can run an update query
171,Reading ResultSet [5 9 methods],while(rs.next()) { int id = rs.getInt(“id”); }NEWLINE.getBoolean(); .getInt(...); .getDouble(); .getLong(); // Int not spelled in fullNEWLINE.getString(...); .getObject();NEWLINE.getData(); .getTime(); .getTimeStamp(); // java.sql.Date/Time/TimeStampNEWLINEArgument is column label or number; Numbers start at 1 not 0;
172,SQL Date Conversion [2],java.sql.Date sqlDate = rs.getDate(1);NEWLINELocalDate localDate = sqlDate.toLocalDate(); // This is a method not a factory
173,JDBC Date and Time [3],java.sql.Date - java.time.LocalDate - Date onlyNEWLINEjava.sql.Time - java.time.LocalTime - Time onlyNEWLINEjava.sql.TimeStamp - java.time.LocalDateTime - Date and Time
174,Scrolling ResultSet [8 methods],void afterLast(); void beforeFirst(); // Surprisingly these return void. NEWLINEboolean first(); boolean last(); boolean next(); boolean previous() // Spelling in full!NEWLINEboolean absolute(int rowNum); boolean relative(int rowNum); // Negative numbers start from end. absolute(0) = false; Extreme relative numbers place in beforeFirst or afterLast position.NEWLINEClosing Database Resources [5]NEWLINETry (Connection conn = DriverManager.getConnection(url);	….);NEWLINEThe ‘old’ way uses a finally block and lots of checks to see what still is open. NEWLINEExceptionsNEWLINEcatch(SQLException e) { e.getMessage(); e.getSQLState(); e.getErrorCode(); }
175,Closing Database Resources [5],Try (Connection conn = DriverManager.getConnection(url);	….);NEWLINEThe ‘old’ way uses a finally block and lots of checks to see what still is open. NEWLINEExceptionsNEWLINEcatch(SQLException e) { e.getMessage(); e.getSQLState(); e.getErrorCode(); }NEWLINEAlso note that ResultSet has a close method that automatically gets called when a  new rs is assigned of the Statement closes.
